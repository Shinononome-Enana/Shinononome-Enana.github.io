{"meta":{"title":"デジタル旅の休暇所","subtitle":"廻り続ける日々　寄り道をしたら、いつもと違う場所で　めくり逢える、奇跡に。","description":"","author":"ロ　ユイセー(Lu Weicheng)","url":"https://shinononome-enana.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-10-13T09:00:00.000Z","updated":"2025-01-10T08:28:10.382Z","comments":true,"path":"about/index.html","permalink":"https://shinononome-enana.github.io/about/index.html","excerpt":"","text":"关于本网站本博客网站于2024&#x2F;10&#x2F;10日，由Lu Weicheng搭建并私人使用。其主要用途有： 课设代码和工程经验记录 工程、项目记录(思路、代码等) 日语学习的相关记录 记录留学生活中值得纪念的东西 动漫、游戏相关的内容 博主个人信息 现居地：日本福冈县北九州市若松区ひびきの学研都市 联系方式： QQ：1175072426 微信：a1175072426 Bilibili主页：https://space.bilibili.com/123245199?spm_id_from=333.1007.0.0 Csdn主页：https://blog.csdn.net/GalaxyerKw?spm=1000.2115.3001.5343 PPT 课程或科研组会交流用PPT分享在Speaker Deck： https://speakerdeck.com/enana"},{"title":"友情链接","date":"2025-03-16T10:33:33.770Z","updated":"2025-03-16T10:33:33.770Z","comments":true,"path":"friend/index.html","permalink":"https://shinononome-enana.github.io/friend/index.html","excerpt":"","text":"本站信息 站名： デジタル旅の休暇所 站长： 東雲絵名一番大好き男の子：ロ ユイセー(Lu Weicheng) 地址： https://shinononome-enana.github.io/ 备用地址：https://shinononome-enana.github.io/ 申请方法 添加本站后，在本页留言，格式如下 123456```yml- name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片``` 小伙伴们 D-Sketon(灵梦主题开发者) 一个车万人 Offensive77 旮旯给木高手，骨灰级二次元，德国IT理工男，任天堂忠实粉丝，疑似奶龙人间体 welldky 人工智能领域顶尖学者，魂游上手，原神60级，乌蒙地插舞神确认"}],"posts":[{"title":"【修士课题记录03】GPU侧的初步研究：基于YOLOX-6D-Pose网络的改进思路","slug":"master-research-20250423","date":"2025-04-23T13:11:35.000Z","updated":"2025-04-23T13:53:12.157Z","comments":true,"path":"2025/04/23/master-research-20250423/","permalink":"https://shinononome-enana.github.io/2025/04/23/master-research-20250423/","excerpt":"","text":"本周主要针对1ms系统的GPU侧进行了调研。对于Pose Estimation网络部分，找了许多最新的工作，暂时选定了YOLOX-6D-Pose网络为baseline。目前对该网络只进行了YCBV官方数据集的训练和测试，未来的一个月内计划进行自己数据集的加载和预测头(LSTM-Head或者Transformer)的添加。 如下图，最下方的两个小模块就是我想要添加的部分： 基于RGB原图像序列预测 or 基于Pose参数预测？对于本次会议最后提出的问题：进行预测时是基于RGB图像直接encode，还是基于回归得到的Pose参数进行encode好呢？这个问题的起因是我阅读了学长Head Pose Detection的修士论文，发现他是直接对RGB原图像进行transformer，attention等操作的，和我的架构不太一样。李博给出的回答是： 从RGB图像回归到Pose参数，这个过程本身就是对RGB图像某个特定的特征的一种提取操作，因此不可避免会损失一些其他重要的信息。因此，目前的架构仅仅给Transformer投喂Pose参数，作为预测的唯一基准，效果恐怕不是很好。 很有道理，因此，我有了如下的修改预想： 下周的工作 ———— FPGA侧的思考教授一再催促要开始FPGA侧的思考和调研了，下周开始。计划是阅读李博在FPGA上实现hardwired-CNN部署的代码，顺便摸索1ms系统的接口框架。","categories":[{"name":"修士课题记录","slug":"修士课题记录","permalink":"https://shinononome-enana.github.io/categories/%E4%BF%AE%E5%A3%AB%E8%AF%BE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Object Pose Prediction","slug":"Object-Pose-Prediction","permalink":"https://shinononome-enana.github.io/tags/Object-Pose-Prediction/"}]},{"title":"日本語勉強メモ０２ーーＮ２読解·読み物２１～３０","slug":"hinongo-memo02","date":"2025-04-11T00:53:40.000Z","updated":"2025-04-11T06:40:57.032Z","comments":true,"path":"2025/04/11/hinongo-memo02/","permalink":"https://shinononome-enana.github.io/2025/04/11/hinongo-memo02/","excerpt":"","text":"～しようとする（1）打算做…，想做…；表达一种意愿（2）试图做….；表达一种尝试。（3）刚要….的时候，突然又发生了一件事。 他还有其他几种变体，如：「しようとすれば」。他们的意思大致相仿。 已经连续在好几篇文章中见到了。下面贴出原文。 打算做…： 何かにチャレンジしようとした時、「今がどんなに不幸でも、変わろうとすれば、その先でもっと不幸になるかもしれない」という考えが浮かんで、結局やめてしまった。 试图做…: では意識はなぜ、夢の中身をコントロールしようとするのか。 ためです「ためです」结句，解释原因，是因为….。 较为书面化，口语中多为「からです」「のでです」。也可用于句子中顿，去掉「です」，表达同样的意思。 夢には必ずしもストーリーとしての一貫性がありませんが、それは自分の願望をストレートに表現したくない、という意識が働くためなのです。突然場面が変わったり、なんの脈絡もなく人物が次々と登場するのはそのためです。 但对于「ため」这个词而言，我大多数情况下第一反应是表示“为了…”。当然这也没错，但一般这种情况不会用于结句，多是加个に变成「～ために」。 あまり（あんまり）・なかなかあまり其口语形式为あんまり，后接否定「あまり…しない」，表达不怎么….,不太….。 N5语法，现在还要整理复习也是丢死人了 あの新入生の話し方、なんかいつもイライラしてて静かにしてない、あんまり好きじゃないなぁ。 「なかなか…しない」则是表达“怎么也不…”，说话人有些烦躁。 あいつなかなか来ないなぁ、いつも遅刻して、たまらないわ。 あまり和なかなか虽然都表达“不…”，但是他们的语感是完全不一样的。あまり通常称述一种习惯或者事实，而なかなか在表达“不”的时候通常有埋怨、不满的语气。当然，听到なかなか其实我的第一反应是表达一种称赞： なかなかやるじゃん！ たまに「たまに」偶尔、间或、很少有时候，它表示某个动作或状态发生的频率很低，但不是完全没有。 也是N5语法！！！なかなか记不住！ 勉強と仕事の両立をさせる場合には、たまに休暇をとって、勉強を休むのも悪くない。 複数のxxx複数（ふくすう），「複数の…」表示“多个…，不止一个…”，较为书面。口语中则使用「たくさんの」或者「いとんな」即可。 だからこそ複数の企業がしのぎを削って競争をしているわけである。 決して…ない決して(けっして)…ない：绝对不…，一般用于表达一种决心。 決して相手と対立をしようとは思っていないのに、結局としてそれが起こってしまう。 ～する恐れがある「恐れがある」表示“可能会….；有….的风险”，相较于「かもしれません」更为书面和正式，在日常生活中的提示牌中也经常会看到。 塩分を取りすぎると、高血圧を引き起こす恐れがある。 日常茶飯事「日常茶飯事（にちじょうさはんじ）」表示“…也是常有的事，经常发生的事”。这个词给我映像很深的原因是，我那天刚在书上背完他，转手刷视频的时候就看到了！ とくに、ビジネスの現場ではそのようなことは日常茶飯事だ。 这里给出我看到的视频的截图。（这个视频是一个已经辞退的JR车掌在揭露公司里的潜规则） 另：短语整理","categories":[{"name":"Ｎ２日本語勉強メモ","slug":"N２日本語勉強メモ","permalink":"https://shinononome-enana.github.io/categories/N%EF%BC%92%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8B%89%E5%BC%B7%E3%83%A1%E3%83%A2/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}]},{"title":"【修士课题记录02】在FPGA-GPU异构架构上实现Pose Prediction相关细节的讨论","slug":"master-research-20250401","date":"2025-04-01T04:18:00.000Z","updated":"2025-04-11T00:43:18.557Z","comments":true,"path":"2025/04/01/master-research-20250401/","permalink":"https://shinononome-enana.github.io/2025/04/01/master-research-20250401/","excerpt":"","text":"My proposal 受到王维论文的启发，基于他的思路，我提出了在1ms系统上实现物体位姿预测的proposal，核心有两点： GPU上实现关键帧Pose Prediction：取连续几帧关键帧，获取他们的temporal和spatial信息来对未来的关键帧进行预测，得到预测的absolute pose。 以往的1ms系统的GPU-FPGA结构中，以王维的工作为例，GPU只对当前的一个关键帧进行estimation，在下一个关键帧到来时运算完毕，这中间存在时间差(具体细节会在下一节讲)。如果使用多关键帧进行预测，就能消除这种误差。 FPGA上部署e2e网络回归一般帧relative pose：使用e2e神经网络，直接回归任意普通帧的relative pose参数。 与王维的工作不同的是，王维通过ORB、2D-3D点匹配、particle filter等算法，对特征点进行提取后分析，然后才得到pose。这显然是rule-based的，鲁棒性有待验证。现在，我要改进为net-based，即直接使用一个端到端的神经网络替代所有rule-based算法。 最后，对于任意一帧：结合GPU上得到的absolute pose(predicted)和FPGA上得到的relative pose，即可得到任意时刻真正的object pose。 这里给出我的idea(右)和previous work(左)的架构对比图： 王维工作：FPGA-GPU架构的细节由于我后期的研究需要基于王维的这篇论文中的思想，因此需要细致深入的理解。 关键词 GPU侧 Key Frame Key Feature Points Key Pose (Absolute Pose) FPGA侧 Normal Frame Normal Feature Points Normal Pose (Relative Pose) 时序由于这是一个GPU与FPGA协助的结构，因此首先要理解时序问题。关键帧KeyFrame每隔m帧选取一帧，在两个关键帧之间的时间内(即下一个关键帧来到之前)，需要GPU完成他对当前关键帧的处理任务；另外，两个关键帧之间的普通帧NormalFrame，参照的是上一个关键帧的estimation结果。具体可以看我画的这张图： GPU侧GPU一方面要通过YOLO生成pose，另一方面还需要得到2D-3D特征点和2D-3D映射关系。 过程1将KeyFrame投入YOLO-6D网络，得到pose参数。这个key pose在最后要和一般帧的relative pose结合成真正的output pose，但在GPU上他还需要作为过程2； 过程2的输入是生成的key pose与CAD模型数据，通过Cross-Spatial Fusion模块得到一个遮罩mask与特征点。右侧，key pose用于旋转CAD模型直至与当前pose吻合，用于后续2D-3D特征点映射的生成；左侧，遮罩Mask的作用在论文Fig.3和Fig.4有详细阐述，其作用是辅助生成稳定可靠的特征点，避免了物体在旋转时部分特征点的失效。 FPGA侧过程3运用传统ORB算法，从一般帧中提取特征点normal feature points。在这个过程中，也借助了GPU侧运算出的关键帧特征点key feature points。 过程4通过粒子滤波的rule-based算法，将特征点信息最终转化为object pose。虽然他的鲁棒性有待考证，但考虑到FPGA的部署问题和1ms的延时需求，王维并没有使用常规的PnP等会给FPGA带来巨大压力的递归算法，这也算是一个好的点。但我做的e2e网络肯定要在这方面打败他 同时我们也要注意到，t+i-1时刻(前一帧)的pose信息被反馈到粒子滤波算法中，用于生成t+i时刻(当前帧)的pose；由此可见，粒子滤波将相邻帧强关联起来。 GPU-FPGA交互GPU-FPGA交互体现在两个点： 协同工作：GPU关键帧Adjust —&gt; FPGA每个一般帧。 最后阶段：GPU与FPGA得到的key-pose与relative-pose整合为最终输出pose。 从图里也可以很清晰地看到，GPU侧得到的2D和3D特征点传到FPGA中，分别辅助于FPGA上的ORB算法和粒子滤波，进行一般帧特征点提取和特征点推导pose。这一步或许就是传统1ms结构中提到的用当前关键帧Adjust未来帧。 最后一步，关键帧KeyPose和普通帧RelativePose整合成最终输出pose。","categories":[{"name":"修士课题记录","slug":"修士课题记录","permalink":"https://shinononome-enana.github.io/categories/%E4%BF%AE%E5%A3%AB%E8%AF%BE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Object Pose Prediction","slug":"Object-Pose-Prediction","permalink":"https://shinononome-enana.github.io/tags/Object-Pose-Prediction/"}]},{"title":"日本語勉強メモ０１ーーＮ２読解·読み物１１～２０","slug":"hinongo-memo01","date":"2025-03-26T13:25:32.000Z","updated":"2025-04-11T00:43:42.888Z","comments":true,"path":"2025/03/26/hinongo-memo01/","permalink":"https://shinononome-enana.github.io/2025/03/26/hinongo-memo01/","excerpt":"","text":"あるいは（または・もしくは・それとも）あるいは(或は)：或者，亦或是。它的意思等于または(又は)和もしくは，但较为正式和书面。 另外，それとも常用语疑问句中，表达“还是…?或者…?”的意思。 动漫里有一个很经典的桥段可能是我从哪儿听来的，妻子迎接下班回家的丈夫，说“欢迎回家！是先吃饭呢？还是先洗澡呢？还是说…先吃我呢？”,这里就用到了それとも。 お帰りなさい。ご飯にする？お風呂にする？それとも、わ・た・し？ 狙う狙う（ねらう）：以….为目标。 这里给出几个例句。 勝利を狙っていまう。 以胜利为目标チャンスを狙います。 抓住机会来年はＮ１合格を狙って勉強しています。 努力学习，目标明年通过N1。 这个单词真的太常见了，网上和日常都在用。 わざとわざと：故意地….，后面接续动词。 わざとじゃないよ、本当に間違えただけ！ 我不是故意的，我真的只是弄错了。 我们直接拿阅读中的原文感受一下： ブレーンストーミングをするときに、わざと空気の読めない人を入れることによって、議論が発展的になるという話がある。 問う問う·問います（とう·といます）：询问。这个词要比常规的「聞く」更加正式严肃。 与「問う」组合形成的一些复合动词： 問い直す： 质疑，重新思考。 問い合わせる： (两个人面对面)咨询，询问。 值得一提的是， 「問い合わせ」这个词在日常生活中真是太常见了，我在这里随便贴两个随手拍的： 「割」：割合、役割「割」在日语中有分配，分担的意思。从字面上理解，我们“割”一刀下去，就是把一个东西分成不同的部分。基于这一点，我们需要记忆一些单词： 割合 (わりあい): 比例。 役割 (やくわり): 本意是“角色，分工”，引申义为“作用，功能”。 割り勘 (わりかん): AA制，各付各的。 割引 (わりびき): 打折。 xx + 合わせる合わせる（あわせる）：它的本义是“使…合在一起；配合；协调”的意思，可以理解成把两个东西“对齐”。他能与其他许多动词组成许多不同的复合动词，常见的有： 打ち合わせる: 会议，商讨。和ミーティング一样。 問い合わせる: 咨询，询问。 待ち合わせる: 约定见面。 另外，「合わせる」把最后的る去掉，就变成了名词「合わせ」。由它构成的复合动词也一样，比如「打ち合わせ」就代表会议。 むしろ「むしろ」通常作为句子之间的接续，表示一种转折，可以翻译成“反倒，反而…”。我们可以看一下阅读中的原句。 でも、そういう教育を受けできた人たちが、我慢強く自信に満ち溢れているかといえば、むしろその反対でいらいらしている人が目立ちます。 常用的句型有： （～より&#x2F;というより、）むしろ… : 与其说是，不如说是…。- ～かと思ったけど、むしろ…だった。: はるかに・ずっと「はるかに」作为副词，后通常接形容词（尤其是比较级表达前），表示“远远….”。 比如「彼よりはるかに高い」。 但是「はるかに」表达较为书面，口语中一般用「ずっと」表达“….得多”。 彼の成績は私よりはるかにいいです。彼の成績俺よりずっといいっす。 另外可以提一嘴「かなり」，它也表示“相当…”，但是程度要比前两位稍微低一些。","categories":[{"name":"Ｎ２日本語勉強メモ","slug":"N２日本語勉強メモ","permalink":"https://shinononome-enana.github.io/categories/N%EF%BC%92%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8B%89%E5%BC%B7%E3%83%A1%E3%83%A2/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}]},{"title":"解决Linux系统突然出现Read-only file system导致文件无法写入磁盘的问题(双系统)","slug":"linux-memo01","date":"2025-03-23T11:02:26.000Z","updated":"2025-03-23T11:43:14.371Z","comments":true,"path":"2025/03/23/linux-memo01/","permalink":"https://shinononome-enana.github.io/2025/03/23/linux-memo01/","excerpt":"","text":"问题起因今天在看论文时想顺便写一下笔记，但当我touch记事本的时候失败，告诉我read only文件系统。之前也遇到过同样的问题。 123 ∅ /home/enana/ReadingPapers/pose prediction ▓▒░──────────────────────────░▒▓ 18:27:02 ❯ touch memo.txt touch: cannot touch &#x27;memo.txt&#x27;: Read-only file system 检查和分析123~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 18:23:39 ❯ mount | grep enana /dev/sda1 on /home/enana type fuseblk (ro,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,blksize=4096) 我发现挂载在&#x2F;dev&#x2F;sda1(我自己的1T磁盘)上的&#x2F;home&#x2F;enana(我存放所有文件的目录)不知道怎么会是变成了ro(read-only)状态了。 尝试umount后重新挂载，结果告诉我unclean file system，貌似是检测到windows系统了。 1234567891011 ~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 18:23:51 ❯ sudo umount /home/enana ~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 18:24:14 ❯ sudo mount -a The disk contains an unclean file system (0, 0).Metadata kept in Windows cache, refused to mount.Falling back to read-only mount because the NTFS partition is in anunsafe state. Please resume and shutdown Windows fully (no hibernationor fast restarting.)Could not mount read-write, trying read-only 这时候我突然意识到，可能是因为我这台主机是双系统，所以会有这样的问题。前几天，我打开windows进去用了一下光驱玩东方永夜抄，然后就正常关机(也有可能直接按电源键了?)，然后重启切换到linux继续工作。 我怀疑在这个时候就出了点问题：我以为我关闭了windows，事实上windows在磁盘里写了一个挂起标志，用于下一次快速开机(fast boot)。后来查了一下，说是双系统必须要把security boot 和 fast boot关了才行，不然就可能出现这样的问题！ 解决关机。开机，按F2进入BIOS设置(不同主机的按键不一样)。首先找到Boot Configuration-security boot,关闭；然后找到Pre-boot Behavior-Fastboot,改为Minimal模式。 然后进入windows，在控制面板中将fast boot关闭，然后正常关闭windows。这一步之后，因为我们禁用了fast boot,因此windows关机时也就不会在磁盘内挂起了。理论上讲，这样的话windows系统就不会给linux系统制造迷惑了。 我们再次按下机箱上的电源键开机,回到linux,重新进行挂载。&#x2F;home&#x2F;enana变为rw模式，一切回归正常。 123456789 ~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 19:24:22 ❯ sudo mount -a ~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 19:24:28 ❯ mount | grep enana /dev/sda1 on /home/enana type fuseblk (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,blksize=4096) ~ ▓▒░────────────────────────────────────────────────────────────░▒▓ 19:24:57 ❯ (P.S:还有一种更加快捷的解决办法就是在linux里直接使用ntfsfix指令，把windows留在磁盘&#x2F;dev&#x2F;sda1里的挂起杀死。但这个ntfsfix可能会损坏windows系统下存放的一些数据或文件，并且下次启动windows后又会引发同样的问题，届时又要冒着风险ntfsdix一下，治标不治本，建议还是不要这么做。)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shinononome-enana.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://shinononome-enana.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://shinononome-enana.github.io/tags/ubuntu/"}]},{"title":"【修士课题记录01】有关6DoF Object-Pose Estimation课题的学习、调研和讨论","slug":"master-research-20250320","date":"2025-03-20T14:33:27.000Z","updated":"2025-04-11T00:43:11.968Z","comments":true,"path":"2025/03/20/master-research-20250320/","permalink":"https://shinononome-enana.github.io/2025/03/20/master-research-20250320/","excerpt":"","text":"3.20与教授短暂meeting的总结我的三个提案经过3月份对6D物体姿态估计(6DoF Object-Pose Estimation)的学习和调研，以及和Li博的讨论，今天开会时idea也是终于受到了教授的认可。这意味着我今后的修士课题的大方向，很有可能就已经定下来了。下面是我的PPT： 在我的PPT中，我主要阐释了三个关键点： End-to-end Method： 我的目标是构建一个端到端的网络，能够直接回归出6D姿态估计参数T和R。 RGB based, No Depth： 不使用深度信息Tz，而是通过网络去回归这个参数。回归得到深度Tz后，根据pin-hole模型并结合相机内参可以直接计算出Tx和Ty。 Challenging Scenarios： object pose领域有一些较为挑战性的场景，最具代表性的就是texture-less,Symmetric,Occlusion和Transparent。 Prediction ≠ Estimation！基于1ms的object-pose prediction是一个全新的领域Li博士在会议后和我提到，至今还没有人用1ms系统的GPU-FPGA框架做过object-pose prediction相关的工作，如果能把这一部分做好，也是一个相当不错的proposal。我之前错以为pose-rediction就是estimation，但其实并不是这样的。 estimation：输入t时刻的图像，预测物体t时刻(当前)的状态。 prediction：输入t时刻的图像，预测物体t+n时刻(尚未发生)的状态。 再后来，教授给我发了一封邮件，里面提到了他多年前曾提案过的pose prediction的框架结构，从这个图片中就能一目了然了。实验室前辈完成的dual-hand首次提出了使用GPU优化FPGA的1ms框架，关键帧交给GPU进行精确计算，然后在十几(或者有可能是几十)帧之后，反馈回FPGA进行优化。由于GPU运算也有延时，因此这个框架下只能用老的数据优化新的数据，这就是所谓的estimation的局限性。但如果用当前时刻的帧预测十几或几十帧之后物体的状态，此时刚好GPU也运算完成，这样的话就是用预测的数据优化新的数据，这就是所谓的prediction。这是目前实验室尚未踏足的领域。 论文阅读综述：Deep Learning-Based Object Pose Estimation: A Comprehensive Survey这篇综述我觉得最有用的地方在于最后的future direction部分，详细介绍了很多很多值得研究的方向。其中提到的“End-to-end methods integrating detection or segmentation”,“Single RGB image-based methods”和“Model lightweighting”，都与我的想法和1ms系统对速度的要求不谋而合。 当然，这篇文章前面的部分阐述了object-pose estimation的基本概念，对于入门者而言能够增广领域内知识储备，建议耐心看完。 PoseCNN：一个端到端的Object Pose-estimation网络这篇论文非常适合萌新学习，在原理部分详细阐述了object-pose领域的基础知识，包括：物体的6D参数T(Translation:Tx,Ty,Tz)和R(Rotation:一个四元组)的组成，图像的2D参数(cx,cy)等；以及他的配图可以清晰直观地看出物体坐标系和相机坐标系，以及他们之间的关系。 并且，PoseCNN是目前主流的network-based的一个范本，非常值得学习：网络的最初部分是用于feature extraction的CNN网络；随后接上几个并行的网络，将之前提取出的特征(keypoint等)作为输入，分别进行不同的回归工作。最终，整合成为6D的[T | R]预测结果。 方向调研随笔PossibleResearchPoint 关键词1：End-to-end methods传统的方法是先用R-CNN，YOLO等神经网络进行物体识别和特征点提取，然后运用PnP等数学方法求解物体位姿信息[R|T]，使用这样需要迭代求解的数学方法复杂度太高，无法FPGA硬件部署；与之不同的是，我们可以把feature detection和pose estimation两个工作结合，全部用一个神经网络实现。(2025.3.17补)可以参考PoseCNN的网络架构，用e2e神经网络并行完成“语义识别 + 3D Translation预测 + 3D Rotation预测”三项工作。听李渊博士说，这个就是目前的主流做法。 关键词2：texture-less&#x2F;symmetric –&gt; tansparent&#x2F;articulated&#x2F;occlusion objects (挑战性的物体)(1)透明物体 transparent: texture-less + non-color + less of depth information(2)遮挡问题 occlusion: severe occlusion会导致texture和geometric信息大量丢失。(3)柔性物体 articulated: 与常规的rigid body不同，对柔性物体的pose estimation的DoF不止6，并且这样的物体会自我遮挡。 关键词3：lightweighting network为了部署FPGA并达到1ms系统的基本要求，要对网络进行轻量化处理，同时保证一定的精度。 关键词4：RGB camera很多object pose estimation的方法都使用RGBD相机，即能够获取depth深度信息。但是RGBD相机内部的active depth sensor能耗较高(因为他是有源器件)，实际运用中我们更希望使用纯粹的RGB相机。(2025.3.17补充)读PoseCNN有感：如果要预测Transition而又不使用RGBD直接获取深度信息，这就需要我们的网络自己去预测深度Tz。根据Transition预测的基础数学公式，在知道了物体的2D投影坐标(cx,cy)和深度信息Tz，就可以计算出Tx和Ty。这样Transition(Tx,Ty,Tz)就算预测完了。 【Reference】[1] Deep Learning-Based Object Pose Estimation: A Comprehensive Survey[2] Real-Time Seamless Single Shot 6D Object Pose Prediction memo【2025.3.6】根据 Real-Time Seamless Single Shot 6D Object Pose Prediction 中提到，『PoseNet』网络使用CNN结构直接从RGB图像得出物体的6D-pose，这与我们要设计的end-to-end网络思路一致。 接下来阅读论文 A Convolutional Network for Real-Time 6-DOF camera relocalization，了解『PoseNet』。 【3.7】论文中提到，他们是通过修改GoogLeNet实现的，具体细节牵扯到预训练等在内。接下来阅读论文 Going deeper with convolutions，了解『GoogLeNet』。 论文 Going deeper with convolutions中第四节重点讲述『GoogLeNet』中的核心：Inception module。这个模块不仅可以做到多尺度特征提取，而且巧妙使用 1*1kernel 降低通道数,从而降低网络的计算复杂度。这或许可以作为hardware-friendly network的一个参考思路！ 【3.13】从 LITERATURE REVIEW TEXTURELESS OBJECT RECOGNITION 综述里来看，2018年发表的PoseCNN是一个端到端的神经网络。 【3.17】PoseCNN论文阅读完成，是一个极为重要的论文，建议后期多次复读。现在阅读更新的e2e相关的论文。A Pose Proposal and Refinement Network for Better 6D Object Pose Estimation是2021的一篇论文，里面使用e2e网络预测T和R，还使用了3D模型进行refinement，可以阅读。","categories":[{"name":"修士课题记录","slug":"修士课题记录","permalink":"https://shinononome-enana.github.io/categories/%E4%BF%AE%E5%A3%AB%E8%AF%BE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Object Pose Prediction","slug":"Object-Pose-Prediction","permalink":"https://shinononome-enana.github.io/tags/Object-Pose-Prediction/"}]},{"title":"コンビニアルバイト见闻·其一","slug":"conbini-kansou-01","date":"2025-03-17T15:29:34.000Z","updated":"2025-03-17T16:12:57.897Z","comments":true,"path":"2025/03/18/conbini-kansou-01/","permalink":"https://shinononome-enana.github.io/2025/03/18/conbini-kansou-01/","excerpt":"","text":"前言今天是2025年的3月18号，从我寒假开始在便利店打工开始算，已经过去一个多月了。虽然我レジ比之前熟练多了，遇到日本人也不会紧张了，但还是会时不时遇到不会操作的业务（比如怎么卖切手和はがき上次打工才学会，怎么给顾客提网上的チッケト今天才学会），也会经常被田中店长数落我现在已经ptsd了一看到店长就会紧张。 转回正题，写这篇博客的目的是记录一下我在打工时听到的日语，很多都是极为本地化和口语化的，书本上绝对不会教，考试也不会考(？)。 ちっちゃい第一次听到这个词是从一个老奶奶嘴里。日本的老奶奶大多数都会面带笑容对我讲话，而且非常尊重一直说礼貌语，这让我很开心。 お婆さん： 最もちっちゃいな袋お願いします～僕：（ちっちゃい？なにそれ）は。。はい 一开始我还愣了一下，但我其实对这个是有点耳熟的动漫里听到过，后来思考了十秒钟后猜她大概是表达 ちいさい 的意思，有可能是老年人口齿不清了。于是我就拿了一个最小的袋子给她，这一次收银这就这样顺利结束。在这之后，我又从其他几名顾客口中听到了ちっちゃい这样的表达。 后来，又一次下班以后回去查了一下，其实这并不是口齿不清，GPT给我的解释是：「ちっちゃい」确实和「小さい（ちいさい）」意思相近，都是表示“小”的意思，但「ちっちゃい」是「小さい」的口语化、可爱化的说法，通常用于日常对话，特别是小孩子或者可爱、轻松的场合。这样确实也合理，因为我在老奶奶眼里确实是个小孩儿… やつ之前学やつ的时候，看到他的汉字写成 奴，总感觉是什么不礼貌的词。包括在动漫里也经常听到这个词。但其实不是的。在我刚上岗的实习期间，店长带着我收银： お客様：おにぎりを温めてください。 店長さん： あっ、これは温めないやつ。 顾客想要我们帮忙热一下饭团，但其实日本的饭团有些是不需要加热直接吃的(那种包着海苔的三角饭团)，这时候店长说了一句“这个是不需要加热的”，使用了やつ这个词。所以我觉得，在日常中所说的やつ大概率就等同于もの，只是更加口语化和略带随意罢了。 いいです&#x2F;結構です虽然书上和网上都说：いいです 或者 結構です，可能表达需要也可能表达不需要，因此可能会产生误解和迷惑。但从我这一个多月的经验来看，但凡涉及到提问“是否需要xxx东西”的时候，如果日本人回答 いいです 或者 結構です 就是表达“不需要”的意思了。当然，お願いします 表达的需要和 大丈夫です&#x2F;そのままで 表达的不需要是最直观能听懂的，不会有任何的异议。 最常见的对话就是这个了： 僕：レジ袋ご利用ですか。 需要袋子吗？お客様：あっ、いいです。 啊，不用了。 ちょうだい这个听到的不多，但是从中年男性顾客口中听到过两三次。 男のお客様：１２５番のタバコ３つちょうだい！ 「ちょうだい」是「ください」的更口语、更随意的表达方式，有“给我……”的意思，通常用于熟人或地位相对平等的人之间。这个时候和平时一下简单回应はい或者かしこまりました就可以了。 箸一膳这可能算是个基础的语法，但我之前没好好学我当初觉得日语量词太麻烦所以直接怯战了，在打工的时候顺便学会了。筷子的量词要用膳(ぜん): 一膳（いちぜん） → 一双筷子 二膳（にぜん） → 两双筷子 三膳（さんぜん） → 三双筷子","categories":[{"name":"Life in Japan","slug":"Life-in-Japan","permalink":"https://shinononome-enana.github.io/categories/Life-in-Japan/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"},{"name":"アルバイト","slug":"アルバイト","permalink":"https://shinononome-enana.github.io/tags/%E3%82%A2%E3%83%AB%E3%83%90%E3%82%A4%E3%83%88/"}]},{"title":"使用PSO-NN解决双螺旋分类TSNP问题","slug":"TSNP—problem","date":"2025-03-14T11:23:46.000Z","updated":"2025-03-14T12:30:03.744Z","comments":true,"path":"2025/03/14/TSNP—problem/","permalink":"https://shinononome-enana.github.io/2025/03/14/TSNP%E2%80%94problem/","excerpt":"","text":"核心思想 粒子群算法PSO优化神经网络权重和偏置参数，取代传统的梯度下降法。 神经网络参数矩阵展平，作为PSO算法中粒子的速度参数进行优化。 Presentation PPT 报告 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;random&gt;#include &lt;limits&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;using namespace std;// data parameterconst int num_spiral_rounds = 5;// PSO-Parameterconst double w = 0.2; const double c1 = 1;const double c2 = 2;const double LR = 1.2;const int num_particles = 1000;const int max_iterations = 10000; // NN-Parameterconst int M_hidden_nodes = 32;struct DataPoint &#123; vector&lt;double&gt; input; // Position:(x, y) double label; // Lable: 0 / 1&#125;;struct Particle &#123; vector&lt;double&gt; position; vector&lt;double&gt; velocity; vector&lt;double&gt; best_position; double best_fitness; &#125;;struct GlobalBest &#123; vector&lt;double&gt; position; double fitness; &#125;;double Tanh_activation_function(double x) &#123; return tanh(x);&#125;double Sigmiod_activation_function(double x) &#123; return 1.0 / (1.0 + exp(-x));&#125;double ReLU_activation_function(double x) &#123; return max(0.0, x);&#125;double fitness_function(const vector&lt;double&gt;&amp; position, const vector&lt;DataPoint&gt;&amp; data, int hidden_nodes) &#123; //==================== 2-layer NN dim ==================== int input_dim = 2; int hidden_dim = hidden_nodes; int output_dim = 1; //==================== Extract (W,b) from particles&#x27; weight sequence ==================== vector&lt;vector&lt;double&gt;&gt; input_to_hidden(input_dim, vector&lt;double&gt;(hidden_dim)); vector&lt;double&gt; hidden_to_output(hidden_dim); vector&lt;double&gt; hidden_bias(hidden_dim); double output_bias; int idx = 0; // 2*M: W (Input-&gt;Hidden) for (int i = 0; i &lt; input_dim; i++) &#123; for (int j = 0; j &lt; hidden_dim; j++) &#123; input_to_hidden[i][j] = position[idx++]; &#125; &#125; // 1*M: W (Hidden-&gt;Output) for (int j = 0; j &lt; hidden_dim; j++) &#123; hidden_to_output[j] = position[idx++]; &#125; // 1*M: b (Hidden) for (int j = 0; j &lt; hidden_dim; j++) &#123; hidden_bias[j] = position[idx++]; &#125; // 1: b(Output) output_bias = position[idx]; //==================== Forward-Propagate: Build up the NN / then get error for PSO to optimize position(W,b) ==================== double error = 0.0; int correct_predictions = 0; //for every data for (const auto&amp; sample : data) &#123; const vector&lt;double&gt;&amp; input = sample.input; double true_output = sample.label; //Forward-Propagate: HiddenLayer vector&lt;double&gt; hidden_output(hidden_dim, 0.0); for (int j = 0; j &lt; hidden_dim; j++) &#123; for (int i = 0; i &lt; input_dim; i++) &#123; //y = w1*x1 + w2*x2 + b hidden_output[j] += input[i] * input_to_hidden[i][j]; //y = w1*(x1^2+x2^2) + w2*(x1*x2) + b /* if(i == 1) hidden_output[j] += input_to_hidden[i-1][j] * (pow(input[i-1],2) + pow(input[i],2)) + input_to_hidden[i][j] * (input[i-1] * input[i-1]); else continue; */ //y = w1*sinx1 + w2*cosx2 + b /* if(i == 1) hidden_output[j] += sin(input[i-1]) * input_to_hidden[i-1][j] + cos(input[i]) * input_to_hidden[i][j]; else continue; */ &#125; hidden_output[j] += hidden_bias[j]; hidden_output[j] = Tanh_activation_function(hidden_output[j]); //hidden_output[j] = ReLU_activation_function(hidden_output[j]); //hidden_output[j] = Sigmiod_activation_function(hidden_output[j]); &#125; //Forward-Propagate: OutputLayer double output = 0.0; for (int j = 0; j &lt; hidden_dim; j++) &#123; output += hidden_output[j] * hidden_to_output[j]; &#125; output += output_bias; output = Sigmiod_activation_function(output); //Error Calculation error += pow(output - true_output, 2) / data.size(); // Accuracy calculation int predicted_label = (output &gt;= 0.5) ? 1 : 0; if (predicted_label == true_output) &#123; correct_predictions++; &#125; &#125; double accuracy = static_cast&lt;double&gt;(correct_predictions) / data.size(); //double E = error + (1-accuracy); double E = error; return E;&#125;GlobalBest pso(const vector&lt;DataPoint&gt;&amp; data, int hidden_nodes, int num_particles, int max_iterations) &#123; int dim = 2 * hidden_nodes + hidden_nodes + hidden_nodes + 1; // Particle.Position dim: 2*M + 1*M + 1*M + 1; //==================== Initialization of Particles ==================== random_device rd; mt19937 gen(rd()); uniform_real_distribution&lt;&gt; dist(0.0, 1.0); vector&lt;Particle&gt; particles(num_particles); GlobalBest global_best; global_best.fitness = numeric_limits&lt;double&gt;::infinity(); for (auto&amp; particle : particles) &#123; particle.position.resize(dim); particle.velocity.resize(dim); particle.best_position.resize(dim); for (int i = 0; i &lt; dim; i++) &#123; particle.position[i] = dist(gen); particle.velocity[i] = dist(gen) * 0.1; &#125; particle.best_position = particle.position; particle.best_fitness = fitness_function(particle.position, data, hidden_nodes); if (particle.best_fitness &lt; global_best.fitness) &#123; global_best.position = particle.best_position; global_best.fitness = particle.best_fitness; &#125; &#125; // PSO迭代 ofstream outfile(&quot;result/fitness_results_ARM5.txt&quot;); for (int iter = 0; iter &lt; max_iterations; iter++) &#123; for (auto&amp; particle : particles) &#123; double fitness = fitness_function(particle.position, data, hidden_nodes); if (fitness &lt; particle.best_fitness) &#123; particle.best_fitness = fitness; particle.best_position = particle.position; &#125; if (fitness &lt; global_best.fitness) &#123; global_best.fitness = fitness; global_best.position = particle.position; &#125; for (int i = 0; i &lt; dim; i++) &#123; double r1 = dist(gen), r2 = dist(gen); particle.velocity[i] = w * particle.velocity[i] + c1 * r1 * (particle.best_position[i] - particle.position[i]) + c2 * r2 * (global_best.position[i] - particle.position[i]); particle.position[i] += particle.velocity[i] * LR; &#125; &#125; cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; iter + 1 &lt;&lt; &quot;: Best Fitness(ErrorRate) = &quot; &lt;&lt; global_best.fitness &lt;&lt; endl; outfile &lt;&lt; &quot;Iteration &quot; &lt;&lt; iter + 1 &lt;&lt; &quot;: Best Fitness(ErrorRate) = &quot; &lt;&lt; global_best.fitness &lt;&lt; endl; &#125; outfile.close(); return global_best;&#125;// Two-Nested-Spiralsvector&lt;DataPoint&gt; generate_spiral_data(int num_points, int num_turns) &#123; vector&lt;DataPoint&gt; data; double pi = 3.141592653589793; for (int i = 0; i &lt; num_points; i++) &#123; double t = i * pi * num_turns / num_points; data.push_back(\\&#123;\\&#123;t * cos(t), t * sin(t)\\&#125;, 0.0\\&#125;); data.push_back(\\&#123;\\&#123;-t * cos(t), -t * sin(t)\\&#125;, 1.0\\&#125;); &#125; return data;&#125;void normalize_data(vector&lt;DataPoint&gt;&amp; data, double max_value) &#123; for (auto&amp; point : data) &#123; point.input[0] /= max_value; point.input[1] /= max_value; &#125;&#125;pair&lt;vector&lt;DataPoint&gt;, vector&lt;DataPoint&gt;&gt; split_data_for_validation(const vector&lt;DataPoint&gt;&amp; data, double validation_ratio) &#123; int validation_size = static_cast&lt;int&gt;(data.size() * validation_ratio); vector&lt;DataPoint&gt; shuffled_data = data; random_device rd; mt19937 gen(rd()); shuffle(shuffled_data.begin(), shuffled_data.end(), gen); vector&lt;DataPoint&gt; validation_data(shuffled_data.begin(), shuffled_data.begin() + validation_size); vector&lt;DataPoint&gt; training_data(shuffled_data.begin() + validation_size, shuffled_data.end()); return &#123;training_data, validation_data&#125;;&#125;double test_model(const vector&lt;double&gt;&amp; best_position, const vector&lt;DataPoint&gt;&amp; test_data, int hidden_nodes) &#123; int input_dim = 2; int hidden_dim = hidden_nodes; //==================== Extract (W,b) from the trained weights ==================== vector&lt;vector&lt;double&gt;&gt; input_to_hidden(input_dim, vector&lt;double&gt;(hidden_dim)); vector&lt;double&gt; hidden_to_output(hidden_dim); vector&lt;double&gt; hidden_bias(hidden_dim); double output_bias; int idx = 0; // 2*M: W (Input-&gt;Hidden) for (int i = 0; i &lt; input_dim; i++) &#123; for (int j = 0; j &lt; hidden_dim; j++) &#123; input_to_hidden[i][j] = best_position[idx++]; &#125; &#125; // 1*M: W (Hidden-&gt;Output) for (int j = 0; j &lt; hidden_dim; j++) &#123; hidden_to_output[j] = best_position[idx++]; &#125; // 1*M: b (Hidden) for (int j = 0; j &lt; hidden_dim; j++) &#123; hidden_bias[j] = best_position[idx++]; &#125; // 1: b(Output) output_bias = best_position[idx]; //==================== Forward-Propagate for Testing ==================== int correct_predictions = 0; for (const auto&amp; sample : test_data) &#123; const vector&lt;double&gt;&amp; input = sample.input; double true_output = sample.label; // Forward-Propagate: Hidden Layer vector&lt;double&gt; hidden_output(hidden_dim, 0.0); for (int j = 0; j &lt; hidden_dim; j++) &#123; for (int i = 0; i &lt; input_dim; i++) &#123; //y = w1*x1 + w2*x2 + b hidden_output[j] += input[i] * input_to_hidden[i][j]; //y = w1*(x1^2+x2^2) + w2*(x1*x2) + b /* if(i == 1) hidden_output[j] += input_to_hidden[i-1][j] * (pow(input[i-1],2) + pow(input[i],2)) + input_to_hidden[i][j] * (input[i-1] * input[i-1]); else continue; */ //y = w1*sinx1 + w2*cosx2 + b /* if(i == 1) hidden_output[j] += sin(input[i-1]) * input_to_hidden[i-1][j] + cos(input[i]) * input_to_hidden[i][j]; else continue; */ &#125; hidden_output[j] += hidden_bias[j]; hidden_output[j] = Tanh_activation_function(hidden_output[j]); //hidden_output[j] = ReLU_activation_function(hidden_output[j]); //hidden_output[j] = Sigmiod_activation_function(hidden_output[j]); &#125; // Forward-Propagate: Output Layer double output = 0.0; for (int j = 0; j &lt; hidden_dim; j++) &#123; output += hidden_output[j] * hidden_to_output[j]; &#125; output += output_bias; output = Sigmiod_activation_function(output); // Sigmoid activation // Classify and Count Correct Predictions int predicted_label = (output &gt;= 0.5) ? 1 : 0; // Sigmoid threshold at 0.5 if (predicted_label == true_output) &#123; correct_predictions++; &#125; &#125; //==================== Calculate Accuracy ==================== double accuracy = static_cast&lt;double&gt;(correct_predictions) / test_data.size(); return accuracy;&#125;int main() &#123; int num_points = 100 * num_spiral_rounds; vector&lt;DataPoint&gt; data = generate_spiral_data(num_points,num_spiral_rounds); normalize_data(data,30.0); double validation_ratio = 0.2; pair&lt;vector&lt;DataPoint&gt;, vector&lt;DataPoint&gt;&gt; split_result = split_data_for_validation(data, validation_ratio); vector&lt;DataPoint&gt; train_data = split_result.first; vector&lt;DataPoint&gt; validation_data = split_result.second; GlobalBest best_solution = pso(train_data, M_hidden_nodes, num_particles, max_iterations); cout &lt;&lt; &quot;Best Fitness(Minimum-ErrorRate): &quot; &lt;&lt; best_solution.fitness &lt;&lt; endl; double validation_accuracy = test_model(best_solution.position, validation_data, M_hidden_nodes); cout &lt;&lt; &quot;Model Accuracy on Validation Data: &quot; &lt;&lt; validation_accuracy * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl; return 0;","categories":[{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://shinononome-enana.github.io/tags/CPP/"}]},{"title":"Calculator的Verilog实现与上板验证：SystemLSI Project#1 留档","slug":"slsi-calculator-project","date":"2025-02-08T06:43:55.000Z","updated":"2025-02-08T07:15:58.531Z","comments":true,"path":"2025/02/08/slsi-calculator-project/","permalink":"https://shinononome-enana.github.io/2025/02/08/slsi-calculator-project/","excerpt":"","text":"核心功能与创新功能(PPT) 代码汇总板卡顶层模块AP600.v12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// AP600: Interface between top-moudule of calculator and FPGA boardmodule AP600 (clk, reset, pswA, pswB, pswC, pswD, dipA, dipB, hexA, hexB, buzzer, ledA, ledB, ledC, ledD, segA, segB, segC, segD, segE, segF, segG, segH) ; input clk, reset; // Clock, Reset input[4:0] pswA, pswB, pswC, pswD; // Push switch input[7:0] dipA, dipB; // DIP switch input[3:0] hexA, hexB; // Rotary switch output buzzer; // Buzzer output[7:0] ledA, ledB, ledC, ledD;// LED output[7:0] segA, segB, segC, segD, segE, segF, segG, segH ; // 7SEG LED wire [7:0] ledb,ledc,ledd,lede,ledf,ledg,ledh; wire [9:0] push; wire overflow, sign, ce, plus, minus, equal; // for Debug wire [1:0] state; wire [24:0] regb; wire [24:0] rega; wire [3:0] count; wire [3:0] opr; assign push[0] = pswD[0]; assign push[1] = pswC[0]; assign push[2] = pswC[1]; assign push[3] = pswC[2]; assign push[4] = pswB[0]; assign push[5] = pswB[1]; assign push[6] = pswB[2]; assign push[7] = pswA[0]; assign push[8] = pswA[1]; assign push[9] = pswA[2]; assign plus = pswD[3]; //nAk assign minus = pswC[3]; //nCk assign mult = pswB[3]; //x! assign div = pswA[3]; //x^2 assign ce = pswA[4]; assign equal = pswD[4]; assign switch = pswC[4]; assign inverse = pswD[2]; //± assign game = pswD[1]; //进入井字棋游玩模式 // Output assignment assign buzzer = overflow; assign ledA = &#123;overflow,2&#x27;b00, count[0],count[1], opr, state[0], state[1]&#125;; assign ledB = &#123;regb[8], 7&#x27;b0000000&#125;; assign ledC = &#123;regb[0],regb[1],regb[2],regb[3], regb[4],regb[5],regb[6],regb[7]&#125;; assign ledD = &#123;rega[0],rega[1],rega[2],rega[3], rega[4],rega[5],rega[6],1&#x27;b0&#125;; //H最低位，B最高位!!! (A符号位) assign segA = &#123;6&#x27;b000000,sign,1&#x27;b0&#125;; assign segB = ledb; assign segC = ledc; assign segD = ledd; assign segE = lede; assign segF = ledf; assign segG = ledg; assign segH = ledh; calctop calctop(clk, reset, push, ce, plus, minus, mult, div, equal, switch, inverse, sign, ledh, ledg, ledf, lede, ledd, ledc, ledb, overflow, state, rega, regb, count, opr, game);endmodule 运算和显示顶层模块calctop.v1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Calctop: Calculator top modulemodule calctop(clk, reset, push, ce, plus, minus, mult, div, equal, switch, inverse, sign, ledh, ledg, ledf, lede, ledd, ledc, ledb, overflow, state, rega, regb, count, opr, game); input plus, minus, equal, ce, reset, clk; //新增按键 input mult, div, switch, inverse; input game; input [9:0] push; output overflow, sign; //output [7:0] ledh, ledl; output [7:0] ledh, ledg, ledf, lede, ledd, ledc, ledb; // for Debug output [1:0] state; output [24:0] regb; output [24:0] rega; output [3:0] count; output [3:0] opr; wire plusout, minusout, equalout, ceout; // 新增按键 wire multout, divout; wire switchout, inverseout; // wire [9:0] pushout; wire [24:0] wout; calc calc(pushout, plusout, minusout, multout, divout, equalout, switchout, inverseout, clk, reset, ceout, sign, overflow, wout, state, rega, regb, count, opr, gameout); //binled binled(wout, ledl, ledh); binled binled(wout, ledh, ledg, ledf, lede, ledd, ledc, ledb); syncro syncroce(ceout, ce, clk, reset); syncro syncropuls(plusout, plus, clk, reset); syncro syncrominus(minusout, minus, clk, reset); syncro syncroequal(equalout, equal, clk, reset); //新增按键 syncro syncromult(multout, mult, clk, reset); syncro syncrodiv(divout, div, clk, reset); syncro syncroswitch(switchout, switch, clk, reset); syncro syncroinverse(inverseout, inverse, clk, reset); syncro syncrogame(gameout, game, clk, reset); syncro10 syncropush(pushout, push, clk, reset);endmodule 核心模块calc.v123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607`define DECIMAL 0`define OPE 1`define HALT 2`define XY 3 //运算x^y`define DOUBLEJC 4 //运算x!!`define GCD 5 //最大公因数`define LCM 6 //最小公倍数`define MatPre 7 //预处理`define MatPlus 8 //矩阵加`define MatHLS 9 //行列式的值`define MatMult 10 //矩阵乘`define Cov1D 11 //1维序列线性卷积`define P1 12 //玩家一按`define P2 13 //玩家二按`define Judge 14 //判断输赢// Calc: Calculator main modulemodule calc(decimal, plus, minus, mult, div, equal, switch, inverse, clk, reset, ce, sign, overflow, out, state, REGA, REGB, count, opr, game); input [9:0] decimal; input clk, ce, reset, plus, minus, equal; input mult,div; input switch, inverse; input game; output sign, overflow; output [24:0] out; // for Debugging output [3:0] state; output [24:0] REGB; output [24:0] REGA; output [3:0] count; //0-7bit //output add_or_sub; output [3:0] opr; wire [3:0] d; //wire [8:0] alu_out; reg [3:0] state; //七位数:-9999999~9999999// reg [24:0] REGB; //七位数最多9999999=24bit ，开设25bit寄存器，最高位是负数指示位// reg [24:0] REGA; reg [3:0] count; //reg add_or_sub ; reg [3:0] opr; function [3:0] dectobin; input [9:0] in; if(in[9]) dectobin = 9; else if(in[8]) dectobin = 8; else if(in[7]) dectobin = 7; else if(in[6]) dectobin = 6; else if(in[5]) dectobin = 5; else if(in[4]) dectobin = 4; else if(in[3]) dectobin = 3; else if(in[2]) dectobin = 2; else if(in[1]) dectobin = 1; else if(in[0]) dectobin = 0; endfunction assign d=dectobin(decimal);//阶乘表JC_MAPwire[24:0] JC_MAP[10:0];assign JC_MAP[0] = 25&#x27;d1; // 0! = 1assign JC_MAP[1] = 25&#x27;d1; // 1! = 1assign JC_MAP[2] = 25&#x27;d2; // 2! = 2assign JC_MAP[3] = 25&#x27;d6; // 3! = 6assign JC_MAP[4] = 25&#x27;d24; // 4! = 24assign JC_MAP[5] = 25&#x27;d120; // 5! = 120assign JC_MAP[6] = 25&#x27;d720; // 6! = 720assign JC_MAP[7] = 25&#x27;d5040; // 7! = 5040assign JC_MAP[8] = 25&#x27;d40320; // 8! = 40320assign JC_MAP[9] = 25&#x27;d362880; // 9! = 362880assign JC_MAP[10] = 25&#x27;d3628800; // 10! = 3628800reg[3:0] s_cnt; //switch按下计数reg[24:0] x,y;reg[24:0] a,b;reg BranchFSM_running; //正在运算旁支FSM：XYinteger i;integer DOUBLE_JC_MAX = 16;integer XY_MAX = 10; //x^y中y的最大值//矩阵运算reg[2:0] Mat_weishu;reg over;reg[3:0] Mnumber6A,Mnumber5A,Mnumber4A,Mnumber3A,Mnumber2A,Mnumber1A; //矩阵Areg[3:0] Mnumber6B,Mnumber5B,Mnumber4B,Mnumber3B,Mnumber2B,Mnumber1B; //矩阵Breg[3:0] Mnumber7R,Mnumber6R,Mnumber5R,Mnumber4R,Mnumber3R,Mnumber2R,Mnumber1R; //结果矩阵R//井字棋reg[2:0] L_1,M_1,H_1; //玩家一的三行输入情况[H,M,L]reg[2:0] L_2,M_2,H_2; //玩家二的三行输入情况reg[3:0] Pcnt; //玩家步数计数reg[1:0] winner; always @(posedge clk or negedge reset) begin if(!reset) begin REGA &lt;= 0; REGB &lt;= 0; count &lt;= 0; x &lt;= 0; y &lt;= 0; a &lt;= 0; b &lt;= 0; BranchFSM_running &lt;= 0; Mat_weishu &lt;= 0; over &lt;= 0; Mnumber6A &lt;= 0; Mnumber5A&lt;= 0; Mnumber4A&lt;= 0; Mnumber3A&lt;= 0; Mnumber2A&lt;= 0; Mnumber1A&lt;= 0; Mnumber6B &lt;= 0; Mnumber5B&lt;= 0; Mnumber4B&lt;= 0; Mnumber3B&lt;= 0; Mnumber2B&lt;= 0; Mnumber1B&lt;= 0; Mnumber7R &lt;= 0; Mnumber6R &lt;= 0; Mnumber5R&lt;= 0; Mnumber4R&lt;= 0; Mnumber3R&lt;= 0; Mnumber2R&lt;= 0; Mnumber1R&lt;= 0; L_1 &lt;= 0; M_1 &lt;= 0; H_1 &lt;= 0; L_2 &lt;= 0; M_2 &lt;= 0; H_2 &lt;= 0; Pcnt &lt;= 0; winner &lt;= 0; opr &lt;= 0; s_cnt &lt;= 0; state&lt;= `DECIMAL; end else begin case (state) `DECIMAL : begin //switch计数:0 -&gt; 1 -&gt; 2 s_cnt &lt;= (switch==1) ? (s_cnt+1) : s_cnt; if((decimal != 0) &amp;&amp; (count &lt; 7)) //修改位数 begin count &lt;= count + 1; REGA &lt;= REGA * 10 + d; end else if(ce) begin REGA &lt;= 0; count &lt;= 0; end else if(inverse) //± begin REGA &lt;= ~REGA + 1; end else if (game) begin //按下game按键 state &lt;= `P1; REGA &lt;= 1234321; REGB &lt;= 1234321; end //A: 7 8 9 / CE //B: 4 5 6 * C //C: 1 2 3 - S //D: 0 ± + = switch=0 4 8 //----------------------------- //A: 7 8 9 x^2 CE //B: 4 5 6 x! C //C: 1 2 3 mCn S //D: 0 ± mAn = switch=1 5 9 //----------------------------- //A: 7 8 9 x^y CE //B: 4 5 6 x!! C //C: 1 2 3 GCD S //D: 0 ± LCM = switch=2 6 10 //----------------------------- //A: 7 8 9 Mat+ CE //B: 4 5 6 |Mat| C //C: 1 2 3 Mat* S //D: 0 ± 1D-cov = switch=3 7 11 //----------------------------- else if(plus || minus || mult || div || equal) begin if(s_cnt == 0 || s_cnt % 4 == 0) begin case(opr) 4&#x27;b0000: REGB &lt;= REGB + REGA; 4&#x27;b0001: REGB &lt;= REGB - REGA; 4&#x27;b0010: REGB &lt;= REGB * REGA; 4&#x27;b0011: REGB &lt;= REGB / REGA; endcase if(plus) opr &lt;= 4&#x27;b0000; else if(minus) opr &lt;= 4&#x27;b0001; else if(mult) opr &lt;= 4&#x27;b0010; else if(div) opr &lt;= 4&#x27;b0011; else opr &lt;= opr; end // else if(s_cnt % 4 == 1) begin case(opr) 4&#x27;b0000: REGB &lt;= REGB + REGA; 4&#x27;b0001: REGB &lt;= JC_MAP[REGB] / JC_MAP[REGB - REGA]; //nAk: n个里选择k个 n!/(n-k)! 4&#x27;b0010: REGB &lt;= JC_MAP[REGB] / (JC_MAP[REGA] * JC_MAP[REGB - REGA]); //nCk 4&#x27;b0011: REGB &lt;= JC_MAP[REGB]; 4&#x27;b0100: REGB &lt;= REGB * REGB; endcase if(plus) opr &lt;= 4&#x27;b0001; //nAk else if(minus) opr &lt;= 4&#x27;b0010; //nCk else if(mult) opr &lt;= 4&#x27;b0011; //x! else if(div) opr &lt;= 4&#x27;b0100; //x^2 else opr &lt;= opr; end else if(s_cnt % 4 == 2) begin case(opr) 4&#x27;b0000: REGB &lt;= REGB + REGA; 4&#x27;b0100: begin //x^y x &lt;= REGB; y &lt;= REGA; state &lt;= `XY; end 4&#x27;b0011: begin //x!! 输入必须按两次一样的数， 比如5!!就要按5!!5 x &lt;= REGB; y &lt;= REGB; state &lt;= `DOUBLEJC; end 4&#x27;b0010: begin //GCD辗转相除法: x=max(REGA,REGB),y=min(REGA,REGB), (x,y)&lt;-(y,x % y) x &lt;= (REGA &gt; REGB) ? REGA : REGB; y &lt;= (REGA &lt; REGB) ? REGA : REGB; state &lt;= `GCD; end 4&#x27;b0001: begin //LCM = (a * b) /GCD x &lt;= (REGA &gt; REGB) ? REGA : REGB; y &lt;= (REGA &lt; REGB) ? REGA : REGB; state &lt;= `LCM; end endcase if(plus) opr &lt;= 4&#x27;b0001; //LCM else if(minus) opr &lt;= 4&#x27;b0010; //GCD else if(mult) opr &lt;= 4&#x27;b0011; //x!! else if(div) opr &lt;= 4&#x27;b0100; //x^y else opr &lt;= opr; end else if(s_cnt % 4 == 3) begin case(opr) 4&#x27;b0000: REGB &lt;= REGB + REGA; //支持的矩阵大小： 1*2 2*2 3*2 //逐行展平：比如矩阵[ [2,3,1] ; [1,4,8] ]即输入231148 //首先前往MatPre状态预处理，然后分别前往MatPlus,MatMult和hls 4&#x27;b0001: begin //一维离散序列线性卷积 //state &lt;= `Cov1D; state &lt;= `MatPre; end 4&#x27;b0010: begin //state &lt;= `MatMult; state &lt;= `MatPre; end 4&#x27;b0011: begin //state &lt;= `MatHLS; state &lt;= `MatPre; end 4&#x27;b0100: begin //state &lt;= `MatPlus; state &lt;= `MatPre; end endcase if(plus) opr &lt;= 4&#x27;b0001; //1D-cov else if(minus) opr &lt;= 4&#x27;b0010; //Mat* else if(mult) opr &lt;= 4&#x27;b0011; //|Mat| else if(div) opr &lt;= 4&#x27;b0100; //Mat+ else opr &lt;= opr; end if(BranchFSM_running == 0) begin //!!!!!!!!!!!!!!!!!!!!!!!!! state &lt;= `OPE; REGA &lt;= 0; end end end `OPE: begin if (((REGB[24]==1)&amp;&amp;(REGB&lt;16777216)) //最大负数：1+ 24个0 是能表示的最大负数 || ((REGB[24]==0)&amp;&amp;(REGB&gt;9999999))) state&lt;=`HALT; else if(inverse) REGB &lt;= ~REGB + 1; else if(decimal) begin REGA &lt;= d; //新输入 count &lt;= 1; state &lt;= `DECIMAL; end if(s_cnt % 4 == 2 || s_cnt % 4 == 3) //正在执行DECIMAL-&gt;XY/lcm/gcd/Mat的旁支FSM，运算未结束时暂时不要跳转到OPE!!!!!!!!! BranchFSM_running &lt;= 1; end `HALT: if(ce) begin REGA &lt;= 0; REGB &lt;= 0; opr &lt;= 0; count &lt;= 0; state &lt;= `DECIMAL; end //旁支FSM：负责运算X^Y,x!!,GCD,LCM ---------------------------------------------------------------------------------------------------- `XY: begin y &lt;= y - 1; REGB &lt;= (y == 1) ? REGB : REGB * x; state &lt;= (y == 1) ? `OPE : `XY; end `DOUBLEJC: begin y &lt;= y - 2; if(y == REGB) //第一次 REGB &lt;= REGB; else REGB &lt;= (y &lt;= 1) ? REGB : REGB * y; state &lt;= (y &lt;= 1) ? `OPE : `DOUBLEJC; end `GCD: begin //GCD辗转相除法: x=max(REGA,REGB),y=min(REGA,REGB), (x,y)&lt;-(y,x % y) if(x % y == 0) begin REGB &lt;= y; state &lt;= `OPE; end else begin x &lt;= y; y &lt;= x % y; state &lt;= `GCD; end end `LCM: begin //LCM = (a * b) /GCD if(x % y == 0) begin REGB &lt;= (REGA * REGB) / y; state &lt;= `OPE; end else begin x &lt;= y; y &lt;= x % y; state &lt;= `LCM; end end //矩阵操作---------------------------------- `MatPre: begin //检测位数 if(REGB&gt; 99999) begin //六位数：2*3 Mat_weishu &lt;= 6; end else if(REGB &gt; 9999 &amp;&amp; REGB &lt; 100000) begin //五位数：2*3，最高位补零 Mat_weishu &lt;= 5; end else if(REGB &gt; 999 &amp;&amp; REGB &lt; 10000) begin //四位数： 2*2 Mat_weishu &lt;= 4; end else if(REGB &gt; 99 &amp;&amp; REGB &lt; 1000) begin //三位数： 2*2, 最高位补零 Mat_weishu &lt;= 3; end else if(REGB &gt;9 &amp;&amp; REGB &lt; 100) begin //二位数：1*2 Mat_weishu &lt;= 2; end else if(REGB &gt;=0 &amp;&amp; REGB &lt; 10) begin //一位数： 1*2 ，最高位补0 Mat_weishu &lt;= 1; end else begin Mat_weishu &lt;= 0; end //分割数字 Mnumber6B &lt;= REGB / 100000; Mnumber6A &lt;= REGA / 100000; Mnumber5B &lt;= (REGB % 100000) / 10000; Mnumber5A &lt;= (REGA % 100000) / 10000; Mnumber4B &lt;= (REGB % 10000) / 1000; Mnumber4A &lt;= (REGA % 10000) / 1000; Mnumber3B &lt;= (REGB % 1000) / 100; Mnumber3A &lt;= (REGA % 1000) / 100; Mnumber2B &lt;= (REGB % 100) / 10; Mnumber2A &lt;= (REGA % 100) / 10; Mnumber1B &lt;= (REGB % 10) / 1; Mnumber1A &lt;= (REGA % 10) / 1; //预处理结束，进入对应运算FSM case(opr) 4&#x27;b0001: state &lt;= `Cov1D; 4&#x27;b0010: state &lt;= `MatMult; 4&#x27;b0011: state &lt;= `MatHLS; 4&#x27;b0100: state &lt;= `MatPlus; endcase end `MatPlus: begin case(Mat_weishu) 6: begin //M2*3 Mnumber1R &lt;= Mnumber1A + Mnumber1B; Mnumber2R &lt;= Mnumber2A + Mnumber2B; Mnumber3R &lt;= Mnumber3A + Mnumber3B; Mnumber4R &lt;= Mnumber4A + Mnumber4B; Mnumber5R &lt;= Mnumber5A + Mnumber5B; Mnumber6R &lt;= Mnumber6A + Mnumber6B; over &lt;= 1; end 5: begin //最高位补0，但不用写 Mnumber1R &lt;= Mnumber1A + Mnumber1B; Mnumber2R &lt;= Mnumber2A + Mnumber2B; Mnumber3R &lt;= Mnumber3A + Mnumber3B; Mnumber4R &lt;= Mnumber4A + Mnumber4B; Mnumber5R &lt;= Mnumber5A + Mnumber5B; over &lt;= 1; end 4: begin //M2*2 Mnumber1R &lt;= Mnumber1A + Mnumber1B; Mnumber2R &lt;= Mnumber2A + Mnumber2B; Mnumber3R &lt;= Mnumber3A + Mnumber3B; Mnumber4R &lt;= Mnumber4A + Mnumber4B; over &lt;= 1; end 3: begin Mnumber1R &lt;= Mnumber1A + Mnumber1B; Mnumber2R &lt;= Mnumber2A + Mnumber2B; Mnumber3R &lt;= Mnumber3A + Mnumber3B; over &lt;= 1; end 2: begin //M1*2 Mnumber1R &lt;= Mnumber1A + Mnumber1B; Mnumber2R &lt;= Mnumber2A + Mnumber2B; over &lt;= 1; end 1: begin Mnumber1R &lt;= Mnumber1A + Mnumber1B; over &lt;= 1; end endcase if(over == 1) begin REGB &lt;= Mnumber6R * 100000 + Mnumber5R * 10000 + Mnumber4R * 1000 + Mnumber3R * 100 + Mnumber2R * 10 + Mnumber1R * 1; state &lt;= `OPE; over &lt;= 0; end else state &lt;= `MatPlus; end `MatHLS: begin //只有2*2方阵有行列式：|abcd| = ad - bc if(Mat_weishu != 4 &amp;&amp; Mat_weishu != 3) begin REGB &lt;= 9999999; //没有逆矩阵显示9999999 state &lt;= `OPE; end else begin REGB &lt;= Mnumber4B * Mnumber1B - Mnumber2B * Mnumber3B; state &lt;= `OPE; end end `MatMult: begin //运算 //1*2-REGB[a,b] 与 2*1-REGA[c;d] 相乘为 1*1[ac+bd] if(Mat_weishu == 2) begin Mnumber1R &lt;= Mnumber2B * Mnumber2A + Mnumber1B * Mnumber1A; over &lt;= 1; //REGB &lt;= Mnumber1R; end //2*2-REGB[[a,b];[c,d]] 与 2*2-REGA[[e,f];[g,h]] 相乘为 2*2[[ae+bg],[af+bh];[ce+dg],[cf+dh]] else if(Mat_weishu == 4 || Mat_weishu == 3) begin Mnumber4R &lt;= Mnumber4B * Mnumber4A + Mnumber3B * Mnumber2A; //ae+bg Mnumber3R &lt;= Mnumber4B * Mnumber3A + Mnumber3B * Mnumber1A; //af+bh Mnumber2R &lt;= Mnumber2B * Mnumber4A + Mnumber1B * Mnumber2A; //ce+dg Mnumber1R &lt;= Mnumber2B * Mnumber3A + Mnumber1B * Mnumber1A; //cf+dh over &lt;= 1; //REGB &lt;= Mnumber4R * 1000 + Mnumber3R * 100 + Mnumber2R * 10 + Mnumber1R * 1; end //2*3-REGB[[a,b,c];[d,e,f]] 与 3*2-REGA[[g,h];[i,j];[k,l]] 相乘为 2*2[[ag+bi+ck,ah+bj+cl];[dg+ei+fk,dh+ej+fl]] else if(Mat_weishu == 6 || Mat_weishu == 5) begin Mnumber4R &lt;= Mnumber6B * Mnumber6A + Mnumber5B * Mnumber4A + Mnumber4B * Mnumber2A; //ag+bi+ck Mnumber3R &lt;= Mnumber6B * Mnumber5A + Mnumber5B * Mnumber3A + Mnumber4B * Mnumber1A; //ah+bj+cl Mnumber2R &lt;= Mnumber3B * Mnumber6A + Mnumber2B * Mnumber4A + Mnumber1B * Mnumber2B; //dg+ei+fk Mnumber1R &lt;= Mnumber3B * Mnumber5A + Mnumber2B * Mnumber3A + Mnumber1B * Mnumber1B; //dh+ej+fl over &lt;= 1; //REGB &lt;= Mnumber4R * 1000 + Mnumber3R * 100 + Mnumber2R * 10 + Mnumber1R * 1; end else //不支持的运算 REGB &lt;= 9999999; //结果赋予REGB if(over == 1) begin REGB &lt;= Mnumber4R * 1000 + Mnumber3R * 100 + Mnumber2R * 10 + Mnumber1R * 1; over &lt;= 0; state &lt;= `OPE; end else begin state &lt;= `MatMult; end end `Cov1D: begin //N长序列 和 M长序列 卷积结果是 M+N-1。最高不能超过7，否则无法显示 //直接规定最大 N=4 * M=4 if(Mat_weishu &gt; 4) begin REGB &lt;= 9999999; over &lt;= 1; end else begin Mnumber7R &lt;= Mnumber4B * Mnumber1A; Mnumber6R &lt;= Mnumber3B * Mnumber1A + Mnumber4B * Mnumber2A; Mnumber5R &lt;= Mnumber2B * Mnumber1A + Mnumber3B * Mnumber2A + Mnumber4B * Mnumber3A; Mnumber4R &lt;= Mnumber1B * Mnumber1A + Mnumber2B * Mnumber2A + Mnumber3B * Mnumber3A + Mnumber4B * Mnumber4A; Mnumber3R &lt;= Mnumber3B * Mnumber4A + Mnumber2B * Mnumber3A + Mnumber1B * Mnumber2A; Mnumber2R &lt;= Mnumber2B * Mnumber4A + Mnumber1B * Mnumber3A; Mnumber1R &lt;= Mnumber1B * Mnumber4A; over &lt;= 1; end if(over == 1) begin REGB &lt;= Mnumber7R * 1000000 + Mnumber6R * 100000 + Mnumber5R * 10000 + Mnumber4R * 1000 + Mnumber3R * 100 + Mnumber2R * 10 + Mnumber1R * 1; state &lt;= `OPE; end else begin state &lt;= `Cov1D; end end //井字棋-------------------------------------------------- `P1: begin if((decimal != 0)) begin //键入 H_1[0] &lt;= (d == 7) ? (H_1[0]+ 1) : H_1[0]; H_1[1] &lt;= (d == 8) ? (H_1[1]+ 1) : H_1[1]; H_1[2] &lt;= (d == 9) ? (H_1[2]+ 1) : H_1[2]; M_1[0] &lt;= (d == 4) ? (M_1[0]+ 1) : M_1[0]; M_1[1] &lt;= (d == 5) ? (M_1[1]+ 1) : M_1[1]; M_1[2] &lt;= (d == 6) ? (M_1[2]+ 1) : M_1[2]; L_1[0] &lt;= (d == 1) ? (L_1[0]+ 1) : L_1[0]; L_1[1] &lt;= (d == 2) ? (L_1[1]+ 1) : L_1[1]; L_1[2] &lt;= (d == 3) ? (L_1[2]+ 1) : L_1[2]; Pcnt &lt;= Pcnt + 1; state &lt;= `Judge; end else begin state &lt;= `P1; end REGB &lt;= 1110000; end `P2: begin if((decimal != 0)) begin //键入 H_2[0] &lt;= (d == 7) ? (H_2[0]+1) : H_2[0]; H_2[1] &lt;= (d == 8) ? (H_2[1]+1) : H_2[1]; H_2[2] &lt;= (d == 9) ? (H_2[2]+1) : H_2[2]; M_2[0] &lt;= (d == 4) ? (M_2[0]+1) : M_2[0]; M_2[1] &lt;= (d == 5) ? (M_2[1]+1) : M_2[1]; M_2[2] &lt;= (d == 6) ? (M_2[2]+1) : M_2[2]; L_2[0] &lt;= (d == 1) ? (L_2[0]+1) : L_2[0]; L_2[1] &lt;= (d == 2) ? (L_2[1]+1) : L_2[1]; L_2[2] &lt;= (d == 3) ? (L_2[2]+1) : L_2[2]; Pcnt &lt;= Pcnt + 1; state &lt;= `Judge; end else begin state &lt;= `P2; end REGB &lt;= 111; end `Judge: begin if( H_1 == 3&#x27;b111 || M_1 == 3&#x27;b111 || L_1 == 3&#x27;b111 || &#123;H_1[0],M_1[0],L_1[0]&#125; == 3&#x27;b111 || &#123;H_1[1],M_1[1],L_1[1]&#125; == 3&#x27;b111 || &#123;H_1[2],M_1[2],L_1[2]&#125; == 3&#x27;b111 || &#123;H_1[0],M_1[1],L_1[2]&#125; == 3&#x27;b111 || &#123;H_1[2],M_1[1],L_1[0]&#125; == 3&#x27;b111 ) begin winner &lt;= 1; //玩家一胜利 REGB &lt;= 1111111; state &lt;= `OPE; end else if( H_2 == 3&#x27;b111 || M_2 == 3&#x27;b111 || L_2 == 3&#x27;b111 || &#123;H_2[0],M_2[0],L_2[0]&#125; == 3&#x27;b111 || &#123;H_2[1],M_2[1],L_2[1]&#125; == 3&#x27;b111 || &#123;H_2[2],M_2[2],L_2[2]&#125; == 3&#x27;b111 || &#123;H_2[0],M_2[1],L_2[2]&#125; == 3&#x27;b111 || &#123;H_2[2],M_2[1],L_2[0]&#125; == 3&#x27;b111 ) begin winner &lt;= 2; //玩家二胜利 REGB &lt;= 2222222; state &lt;= `OPE; end else begin //目前没决出胜负或者平 if(Pcnt == 9) begin //下完了但是平局 winner &lt;= 0; REGB &lt;= 5555555; state &lt;= `OPE; end else begin //未决出胜负，继续下 state &lt;= (Pcnt % 2 == 0) ? `P1 : `P2; end end end //More States 》》》 endcase end end assign overflow=(state==`HALT)?1:0; //assign sign=(state==`DECIMAL)? 0: ((state==`OPE)?(REGB[24]) :0); assign sign=(state==`DECIMAL)? REGA[24]: ((state==`OPE)?(REGB[24]) :0); assign out=out_func (state, REGA, REGB); function [24:0] out_func; input [1:0] s; input [24:0] a; input [24:0] b; case(s) `DECIMAL : out_func = a; `OPE : if(b[24]==1) //负数：检查最高位 out_func = ~b + 1; else out_func = b; endcase endfunctionendmodule 八段数码管显示顶层模块binled.v123456789101112131415module binled(in, ledh, ledg, ledf, lede, ledd, ledc, ledb); input [24:0] in; output [7:0] ledh,ledg,ledf,lede,ledd,ledc,ledb; wire [3:0] outh,outg,outf,oute,outd,outc,outb; bintobcd bintobcd(in,outh,outg,outf,oute,outd,outc,outb); ledout ledouth(outh, ledh); ledout ledoutg(outg, ledg); ledout ledoutf(outf, ledf); ledout ledoute(oute, lede); ledout ledoutd(outd, ledd); ledout ledoutc(outc, ledc); ledout ledoutb(outb, ledb); endmodule 二进制转BCD码模块bintobcd.v12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364module bintobcd(in,outh,outg,outf,oute,outd,outc,outb) ; input [24:0] in; output [3:0] outh,outg,outf,oute,outd,outc,outb; wire [24:0] temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9, temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17, temp18, temp19, temp20, temp21, temp22, temp23, temp24; //百万位b assign outb[3] = (in &gt;= 8000000) ? 1 : 0; assign temp1 = (in &gt;= 8000000) ? in - 8000000 : in; assign outb[2] = (temp1 &gt;= 4000000) ? 1 : 0; assign temp2 = (temp1 &gt;= 4000000) ? temp1 - 4000000 : temp1; assign outb[1] = (temp2 &gt;= 2000000) ? 1 : 0; assign temp3 = (temp2 &gt;= 2000000) ? temp2 - 2000000 : temp2; assign outb[0] = (temp3 &gt;= 1000000) ? 1 : 0; assign temp4 = (temp3 &gt;= 1000000) ? temp3 - 1000000 : temp3; //十万位c assign outc[3] = (temp4 &gt;= 800000) ? 1 : 0; assign temp5 = (temp4 &gt;= 800000) ? temp4 - 800000 : temp4; assign outc[2] = (temp5 &gt;= 400000) ? 1 : 0; assign temp6 = (temp5 &gt;= 400000) ? temp5 - 400000 : temp5; assign outc[1] = (temp6 &gt;= 200000) ? 1 : 0; assign temp7 = (temp6 &gt;= 200000) ? temp6 - 200000 : temp6; assign outc[0] = (temp7 &gt;= 100000) ? 1 : 0; assign temp8 = (temp7 &gt;= 100000) ? temp7 - 100000 : temp7; //万位计算d assign outd[3] = (temp8 &gt;= 80000) ? 1 : 0; assign temp9 = (temp8 &gt;= 80000) ? temp8 - 80000 : temp8; assign outd[2] = (temp9 &gt;= 40000) ? 1 : 0; assign temp10 = (temp9 &gt;= 40000) ? temp9 - 40000 : temp9; assign outd[1] = (temp10 &gt;= 20000) ? 1 : 0; assign temp11 = (temp10 &gt;= 20000) ? temp10 - 20000 : temp10; assign outd[0] = (temp11 &gt;= 10000) ? 1 : 0; assign temp12 = (temp11 &gt;= 10000) ? temp11 - 10000 : temp11; // 千位计算e assign oute[3] = (temp12 &gt;= 8000) ? 1 : 0; assign temp13 = (temp12 &gt;= 8000) ? temp12 - 8000 : temp12; assign oute[2] = (temp13 &gt;= 4000) ? 1 : 0; assign temp14 = (temp13 &gt;= 4000) ? temp13 - 4000 : temp13; assign oute[1] = (temp14 &gt;= 2000) ? 1 : 0; assign temp15 = (temp14 &gt;= 2000) ? temp14 - 2000 : temp14; assign oute[0] = (temp15 &gt;= 1000) ? 1 : 0; assign temp16 = (temp15 &gt;= 1000) ? temp15 - 1000 : temp15; // 百位计算f assign outf[3] = (temp16 &gt;= 800) ? 1 : 0; assign temp17 = (temp16 &gt;= 800) ? temp16 - 800 : temp16; assign outf[2] = (temp17 &gt;= 400) ? 1 : 0; assign temp18 = (temp17 &gt;= 400) ? temp17 - 400 : temp17; assign outf[1] = (temp18 &gt;= 200) ? 1 : 0; assign temp19 = (temp18 &gt;= 200) ? temp18 - 200 : temp18; assign outf[0] = (temp19 &gt;= 100) ? 1 : 0; assign temp20 = (temp19 &gt;= 100) ? temp19 - 100 : temp19; // 十位计算g assign outg[3] = (temp20 &gt;= 80) ? 1 : 0; assign temp21 = (temp20 &gt;= 80) ? temp20 - 80 : temp20; assign outg[2] = (temp21 &gt;= 40) ? 1 : 0; assign temp22 = (temp21 &gt;= 40) ? temp21 - 40 : temp21; assign outg[1] = (temp22 &gt;= 20) ? 1 : 0; assign temp23 = (temp22 &gt;= 20) ? temp22 - 20 : temp22; assign outg[0] = (temp23 &gt;= 10) ? 1 : 0; assign temp24 = (temp23 &gt;= 10) ? temp23 - 10 : temp23; // 个位计算h assign outh = (temp24 &gt;= 10) ? temp24 -10 : temp24; endmodule 八段数码管显示模块ledout.v1234567891011121314151617181920212223// Ledout: Translation from BCD to LED_outmodule ledout(in, out); input [3:0] in; output [7:0] out; reg [7:0] out; always @(in) begin case(in) 0: out = 8&#x27;b11111100; 1: out = 8&#x27;b01100000; 2: out = 8&#x27;b11011010; 3: out = 8&#x27;b11110010; 4: out = 8&#x27;b01100110; 5: out = 8&#x27;b10110110; 6: out = 8&#x27;b10111110; 7: out = 8&#x27;b11100000; 8: out = 8&#x27;b11111110; 9: out = 8&#x27;b11110110; default: out = 8&#x27;bXXXXXXXX; endcase endendmodule 跨时钟域同步模块(1bit按键交互)syncro.v12345678910111213141516171819202122232425// Syncro: Asyncronous to Syncronous (1-bit width)module syncro(out, in, clk, reset); parameter WIDTH = 1; input [WIDTH-1:0] in ; output [WIDTH-1:0] out; input clk,reset; reg [WIDTH-1:0] qO,q1,q2; always @(posedge clk or negedge reset) begin if(!reset) begin qO &lt;= 0; q1 &lt;= 0; q2 &lt;= 0; end else begin qO &lt;= ~in; q1 &lt;= qO; q2 &lt;= q1; end end assign out=q1 &amp; (~q2) ;endmodule 跨时钟域同步模块(10bit按键交互)syncro10.v12345678910111213141516171819202122232425// Syncro10: Asyncronous to Syncrnous (10-bit width)module syncro10(out, in, clk, reset) ; parameter WIDTH = 10; input [WIDTH-1:0] in; output [WIDTH-1:0] out; input clk,reset; reg [WIDTH-1:0] qO,q1,q2; always @(posedge clk or negedge reset) begin if(!reset) begin qO &lt;= 0; q1 &lt;= 0; q2 &lt;= 0; end else begin qO &lt;= ~in; q1 &lt;= qO; q2 &lt;= q1; end end assign out=q1 &amp; (~q2) ;endmodule 后记虽然这个项目中我只是完成了较为简单的运算设计，创新点也较为简单（矩阵和井字棋），没有像有些同学写了小数和负数的运算。但是在上板验证阶段，我的代码一次性通过了所有的测试，准确无误；在课上进行presentation时思路也较为清晰，得到了三位学长助教的一致好评，最终也是拿到了30分满分的好成绩。","categories":[{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"},{"name":"System LSI Design","slug":"Course-Assignment/System-LSI-Design","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/System-LSI-Design/"}],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"https://shinononome-enana.github.io/tags/Verilog/"}]},{"title":"Pipline-CPU的Verilog实现与仿真：SystemLSI Project#2 留档","slug":"slsi-pcpu-project","date":"2025-02-08T05:56:35.000Z","updated":"2025-02-08T07:16:10.526Z","comments":true,"path":"2025/02/08/slsi-pcpu-project/","permalink":"https://shinononome-enana.github.io/2025/02/08/slsi-pcpu-project/","excerpt":"","text":"教授的6个基础test pattern仿真测试 首先，电脑中必须安装iverilog并配置用户的环境变量。 将文件夹下的pcpu.v粘贴修改为自己写好的pcpu.v，然后直接运行run.bat即可在cmd终端查看测试结果。 测试结果如下，测试通过的项目会打上○，未通过则是×。本代码经过测试AC： 注意事项 自己书写的pcpu模块，其管教的顺序必须和测试代码中的保持一致，如果不保持一致必然报错。我之前因为要添加新功能，因此在原有的pcpu模块中添加了一个管教，这导致了所有的测试样例全部不通过！我们打开测试代码，可以看到实例化pcpu的部分如下： 其他注意事项写在代码注释中。 代码（基础版：能够通过教授所有的test pattern）基础版，能够通过教授所有的test pattern。但是相对应的，为了满足测试要求，我关闭了特色功能LWC_INTERRUPT和LWC_CALLBACK：代码中本应该作为输入管教的 i_datain_interrupt 被替代为一个恒为0的reg变量，因此状态机也不会跳转到interrupt中，只会在最基础的idle和exe之间跳转，实现最基础的27条指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500`define NOP 5&#x27;b00000`define HALT 5&#x27;b00001`define LOAD 5&#x27;b00010`define STORE 5&#x27;b00011`define ADD 5&#x27;b01000`define CMP 5&#x27;b01100`define BZ 5&#x27;b11010`define BN 5&#x27;b11100//[------------- LUWEICHENG -------------]// Basic operations`define SUB 5&#x27;b01010`define SUBC 5&#x27;b10010`define ADDC 5&#x27;b10001`define ADDI 5&#x27;b01001`define SUBI 5&#x27;b01011`define LDIH 5&#x27;b10000// Logical/Shift operations`define AND 5&#x27;b01101`define OR 5&#x27;b01110`define XOR 5&#x27;b01111`define SLL 5&#x27;b00100`define SRL 5&#x27;b00101`define SLA 5&#x27;b00110`define SRA 5&#x27;b00111// Control operations`define JUMP 5&#x27;b11000`define JMPR 5&#x27;b11001`define BNZ 5&#x27;b11011`define BNN 5&#x27;b11101`define BC 5&#x27;b11110`define BNC 5&#x27;b11111 //** LWC original operations`define LWC_CLEAR 5&#x27;b10011 //clear: clear one data in rg[val3] 【CLEAR null null val3】`define LWC_CA 5&#x27;b10100 //CA: celete all data in rg 【no op1op2op3, like NOP &amp; HALT】`define LWC_ENCRYPT 5&#x27;b10101 //encrypt: 数据加密 【LWC_ENCRYPT r1 r2 r3】 秘钥：r3; 源码：r2；加密结果存放在r1，秘钥存放在r1+1.`define LWC_INTERRUPT 5&#x27;b10110 //Interrupt: 中断 (Control operation) `define LWC_CALLBACK 5&#x27;b10111 //CallBack: 中断回调//[------------- LUWEICHENG -------------]// FSM for CPU controler`define idle 2&#x27;b00`define exec 2&#x27;b01`define interrupt 2&#x27;b10module pcpu (reset, clock, enable, start, i_addr, i_datain, d_addr, d_datain, d_dataout, d_we, select_y, y);input reset, enable, start, clock; //由顶层于外部连接，由外部(仿真时)控制input [15:0] i_datain;//input [15:0] i_datain_interrupt; //仅做基础test pattern测试时，需要关闭interrupt功能。output [7:0] i_addr;output [7:0] d_addr;input [15:0] d_datain;output [15:0] d_dataout;output d_we;// for Debug ------------ 只是用y看一下内部各个线上的数据input [3:0] select_y;output [15:0] y; //--2025.2.5:For Basic Tests--//reg i_datain_interrupt;// Definition of F/Fsreg [7:0] pc ; //pc: 取指令的指针，指向imem内下一条要执行的指令。reg [15:0] id_ir, ex_ir, mem_ir, wb_ir; //xx_ir: 指令链，不同阶段对指令instruction进行流水线式的存储。reg [15:0] gr [0:7]; //gr: General Register。它是CPU内部的存储器(寄存器堆)。reg [15:0] reg_A, reg_B, reg_C, reg_C1; //reg_X: 数据寄存器，用于CPU内部运算数据的暂存。 [reg_A,reg_B] --&gt; ALU --&gt; [reg_C]reg [15:0] smdr, smdr1; //smdr: 直接存储数据reg zf, nf, dw; //flags: zf(zero flag); nf(negative flag); dw(data write):与d_we相连，是CPU-&gt;dmem写使能。//[------------- LUWEICHENG -------------]reg cf; //carry flag: 进位信号reg[7:0] pc_interrupt; //记录中断前的pc值，中断回调后pc置为 pc_interrupt+1reg inter_flag;//[------------- LUWEICHENG -------------]reg[1:0] state;// Definition of temporary variablesreg [15:0] ALUo;reg [15:0] y;reg[1:0] next_state;assign i_addr = pc; //pc给到i_addr，i_addr输出到imem，取出一条指令assign d_we = dw;assign d_addr = reg_C[7:0]; //从dmem中取data的地址，地址始终存在reg_C中assign d_dataout = smdr1;// CPU Control (FSM)always @(posedge clock or negedge reset) begin if (!reset) state &lt;= `idle; else state &lt;= next_state; endalways @(state or enable or start or wb_ir[15:11]) begin case (state) `idle : if ((enable == 1&#x27;b1) &amp;&amp; (start == 1&#x27;b1)) next_state &lt;= `exec; else next_state &lt;= `idle; `exec : if ((enable == 1&#x27;b0) || (wb_ir[15:11] == `HALT)) next_state &lt;= `idle; else if ((enable == 1&#x27;b0) || (id_ir[15:11] == `LWC_INTERRUPT)) next_state &lt;= `interrupt; else next_state &lt;= `exec; `interrupt: if (id_ir[15:11] == `LWC_CALLBACK) next_state &lt;= `exec; else next_state &lt;= `interrupt; endcase end // IF Block (1st Stage)always @(posedge clock or negedge reset) begin if (!reset) begin id_ir &lt;= 16&#x27;b0000000000000000; pc &lt;= 8&#x27;b00000000; pc_interrupt &lt;= 8&#x27;b00000000; inter_flag &lt;= 0; i_datain_interrupt &lt;= 0; //for professor&#x27;s test pattern, close INTERRUPT using ‘i_datain_interrupt===0’ end else if(state==`exec||state==`interrupt) begin // id_ir &lt;= i_datain; //从imem取指令 id_ir &lt;= (state == `interrupt) ? i_datain_interrupt : i_datain; //主要任务：pc指针控制 if ( ((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1)) || (mem_ir[15:11] == `JMPR) || ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0)) || ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0)) || ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0)) ) //特殊指令跳转： jump to reg_C[7:0]，跳转到ALU运算出来的指令地址。因此必须要根据mem阶段的指令mem_ir判断，否则还没有运算出跳转结果reg_C pc &lt;= reg_C[7:0]; else if (id_ir[15:11] == `JUMP) //JUMP指令跳转: jump to &#123;val2,val3&#125;, 中括号的意思是[7:4]与[3:0]组合为[7:0] pc &lt;= id_ir[7:0]; //[------------- LUWEICHENG -------------] /* //LOAD需要等一拍： 等待运算完成，ALUo值存入rg后，再取值 else if ((id_ir[15:11] == `LOAD) &amp;&amp; (i_datain[15:11]!=`JUMP) &amp;&amp; (i_datain[15:11]!=`NOP) &amp;&amp; (i_datain[15:11]!=`HALT) &amp;&amp; (i_datain[15:11]!=`LOAD)) begin if ( (id_ir[10:8] == i_datain[2:0]) &amp;&amp; ((i_datain[15:11]==`ADD) || (i_datain[15:11]==`ADDC) || (i_datain[15:11]==`SUB) || (i_datain[15:11]==`SUBC) || (i_datain[15:11]==`CMP) || (i_datain[15:11]==`AND) || (i_datain[15:11]==`OR) || (i_datain[15:11]==`XOR)) ) begin pc &lt;= pc; id_ir &lt;= 16&#x27;bXXXXXXXXXXXXXXXX; end else if ( (id_ir[10:8] == i_datain[6:4]) &amp;&amp; ((i_datain[15:11]==`STORE)|| (i_datain[15:11]==`CMP)|| (i_datain[15:11]==`ADD) || (i_datain[15:11]==`ADDC) || (i_datain[15:11]==`SUB) || (i_datain[15:11]==`SUBC) || (i_datain[15:11]==`AND)|| (i_datain[15:11]==`OR) || (i_datain[15:11]==`XOR) || (i_datain[15:11]==`SLL)|| (i_datain[15:11]==`SRL) || (i_datain[15:11]==`SLA)|| (i_datain[15:11]==`SRA)) ) begin pc &lt;= pc; id_ir &lt;= 16&#x27;bXXXXXXXXXXXXXXXX; end else if ( (id_ir[10:8] == i_datain[10:8]) &amp;&amp; ((i_datain[15:11]==`STORE) || (i_datain[15:11]==`LDIH) || (i_datain[15:11]==`SUBI) || (i_datain[15:11]==`JMPR) || (i_datain[15:11]==`BZ) || (i_datain[15:11]==`BNZ) || (i_datain[15:11]==`BN) || (i_datain[15:11]==`BNN) || (i_datain[15:11]==`BC) || (i_datain[15:11]==`BNC))) begin pc &lt;= pc; id_ir &lt;= 16&#x27;bXXXXXXXXXXXXXXXX; end else ; end */ //[------------- LUWEICHENG -------------] //[------------- LUWEICHENG -------------] //interrupt &amp; callback else if (id_ir[15:11] == `LWC_INTERRUPT) begin pc &lt;= 0; //转到imem_interrupt,从0开始 if(inter_flag == 0) begin pc_interrupt &lt;= pc; //记录中断前的pc值 inter_flag &lt;= 1; end end else if (id_ir[15:11] == `LWC_CALLBACK) begin pc &lt;= pc_interrupt; //回到imem end //[------------- LUWEICHENG -------------] else pc &lt;= pc + 1; end else if(state==`idle) //pc停止 pc &lt;= pc; else ; end // ID Block (2nd Stage)always @(posedge clock or negedge reset)begin if (!reset) begin ex_ir &lt;= 16&#x27;b0000000000000000; reg_A &lt;= 16&#x27;b0000000000000000; reg_B &lt;= 16&#x27;b0000000000000000; smdr &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state==`interrupt) begin ex_ir &lt;= id_ir; //ir传递（id -&gt; ex） //[------------- LUWEICHENG -------------] //The general register clearing operations LWC_CLEAR and LWC_CA are executed //directly in the ID stage, no need to wait until the WB if (id_ir[15:11] == `LWC_CA) begin gr[0] = 16&#x27;b0000000000000000; gr[1] = 16&#x27;b0000000000000000; gr[2] = 16&#x27;b0000000000000000; gr[3] = 16&#x27;b0000000000000000; gr[4] = 16&#x27;b0000000000000000; gr[5] = 16&#x27;b0000000000000000; gr[6] = 16&#x27;b0000000000000000; gr[7] = 16&#x27;b0000000000000000; end else if (id_ir[15:11] == `LWC_CLEAR) begin //clear: clear one data in rg[val3] 【CLEAR null null val3】 gr[id_ir[3:0]] = 16&#x27;b0000000000000000; end else ; //[------------- LUWEICHENG -------------] /******************** reg_A 赋予：第一个操作数 *************************************************************************************************************** *********************/ //↓[type:I] r1 val2 val3 形 if ((id_ir[15:11] == `ADDI) || (id_ir[15:11] == `SUBI) || (id_ir[15:11] == `LDIH) || (id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[10:8] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) //无目的寄存器(operand1 = null) reg_A &lt;= ((id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) ? gr[(id_ir[10:8])] : ALUo; //reg_A &lt;= ALUo; else if ((id_ir[10:8] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_A &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[10:8] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_A &lt;= reg_C1; else reg_A &lt;= gr[(id_ir[10:8])]; //取出r1 ############# end //[------------- LUWEICHENG -------------] //↓[type:R] r1 r2 r3 形 else if ((id_ir[15:11] == `LOAD) || (id_ir[15:11] == `STORE) || (id_ir[15:11] == `ADD) || (id_ir[15:11] == `CMP) || (id_ir[15:11] == `ADDC) || (id_ir[15:11] == `SUB) || (id_ir[15:11] == `SUBC) || (id_ir[15:11] == `AND) || (id_ir[15:11] == `OR) || (id_ir[15:11] == `XOR) || (id_ir[15:11] == `SLL) || (id_ir[15:11] == `SRL) || (id_ir[15:11] == `SLA) || (id_ir[15:11] == `SRA) || (id_ir[15:11] == `LWC_ENCRYPT)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[6:4] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) reg_A &lt;= ALUo; else if ((id_ir[6:4] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_A &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[6:4] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_A &lt;= reg_C1; else //[------------- LUWEICHENG -------------] reg_A &lt;= gr[(id_ir[6:4])]; //取出r2 ############# end else if (((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0))|| ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0))|| ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0))|| mem_ir[15:11] == `JMPR) reg_A &lt;= 16&#x27;b0000_0000_0000_0000; else ; /********************* reg_B赋予：第二个操作数*************************************************************************************************************** ******************** */ if (id_ir[15:11] == `LOAD) reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //r1,r2,val3形：只取val3,需要在前面补12位0 ########### else if (id_ir[15:11] == `STORE) begin reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //r1,r2,val3形：只取val3,需要在前面补12位0 ########### //[------------- LUWEICHENG -------------] //smdr的赋值也需要：hazard 避免 if ((id_ir[10:8] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) smdr &lt;= ALUo; else if ((id_ir[10:8] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) smdr &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[10:8] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) smdr &lt;= reg_C1; else //[------------- LUWEICHENG -------------] smdr &lt;= gr[id_ir[10:8]]; //STORE ############# end else if ((id_ir[15:11] == `SLL) || (id_ir[15:11] == `SRL) || (id_ir[15:11] == `SLA) || (id_ir[15:11] == `SRA)) reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //r1,r2,val3形：只取val3,需要在前面补12位0 ########### else if ((id_ir[15:11] == `ADDI) || (id_ir[15:11] == `SUBI) || (id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) reg_B &lt;= &#123;8&#x27;b00000000, id_ir[7:0]&#125;; // r1 val2 val3, 取出&#123;val2,val3&#125;的组合,需要在前面补8位0 ########### else if ((id_ir[15:11] == `LDIH)) reg_B &lt;= &#123;id_ir[7:0], 8&#x27;b00000000&#125;; else if ((id_ir[15:11] == `ADD) || (id_ir[15:11] == `CMP) || (id_ir[15:11] == `ADDC) || (id_ir[15:11] == `SUB) || (id_ir[15:11] == `SUBC) || (id_ir[15:11] == `AND) || (id_ir[15:11] == `OR) || (id_ir[15:11] == `XOR) || (id_ir[15:11] == `LWC_ENCRYPT)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[2:0] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) reg_B &lt;= ALUo; else if ((id_ir[2:0] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_B &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[2:0] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_B &lt;= reg_C1; else // r1 r2 r3，取出r3； ############# reg_B &lt;= gr[id_ir[2:0]]; //[------------- LUWEICHENG -------------] end else if (((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1))|| ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0)) || ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0))|| ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0))|| mem_ir[15:11] == `JMPR) reg_B &lt;= 16&#x27;b0000_0000_0000_0000; else ; endend // EX Block (3rd Stage)always @(posedge clock or negedge reset) begin if (!reset) begin mem_ir &lt;= 16&#x27;b0000000000000000; reg_C &lt;= 16&#x27;b0000000000000000; smdr1 &lt;= 16&#x27;b0000000000000000; zf &lt;= 1&#x27;b0 ; nf &lt;= 1&#x27;b0 ; dw &lt;= 1&#x27;b0 ; end else if(state==`exec||state==`interrupt) begin mem_ir &lt;= ex_ir; reg_C &lt;= ALUo; //reg_C转存ALUo运算结果 smdr1 &lt;= smdr; //flag更新 if ((ex_ir[15:11] == `ADDI) || (ex_ir[15:11] == `SUBI) || (ex_ir[15:11] == `LDIH) || (ex_ir[15:11] == `ADD) || (ex_ir[15:11] == `CMP) || (ex_ir[15:11] == `ADDC) || (ex_ir[15:11] == `SUB) || (ex_ir[15:11] == `SUBC)) // || (ex_ir[15:11] == `AND) || (ex_ir[15:11] == `OR) || (ex_ir[15:11] == `XOR) || (ex_ir[15:11] == `SLL) || (ex_ir[15:11] == `SRL) || (ex_ir[15:11] == `SLA) || (ex_ir[15:11] == `SRA) begin if (ALUo == 16&#x27;b0000000000000000) zf &lt;= 1&#x27;b1; else zf &lt;= 1&#x27;b0; if (ALUo [15] == 1&#x27;b1) nf &lt;= 1&#x27;b1; else nf &lt;= 1&#x27;b0; end else begin zf &lt;= zf; nf &lt;= nf; end if (ex_ir[15:11] == `STORE) begin dw &lt;= 1&#x27;b1; //smdr1 &lt;= smdr; end else dw &lt;= 1&#x27;b0; end end // MEM Block (4th Stege)always @(posedge clock or negedge reset) begin if (!reset) begin wb_ir &lt;= 16&#x27;b0000000000000000; reg_C1 &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state == `interrupt) begin wb_ir &lt;= mem_ir; if (mem_ir[15:11] == `LOAD) //**** `LOAD回路：从dmem取得的数据在d_datain中，先给到reg_C1,然后转存到cpu内部存储gr。程序运行其他操作时，时再从gr取数据。 //其实reg_C一直作为dmem的地址索引，但只有LOAD指令时，cpu才会从dmem中取出数据存入regC_1；其余时候reg_C1转存运算结果reg_C。 reg_C1 &lt;= d_datain; else reg_C1 &lt;= reg_C; end end // WB Block (5th Stage)always @(posedge clock or negedge reset) begin if (!reset) begin gr[0] &lt;= 16&#x27;b0000000000000000; gr[1] &lt;= 16&#x27;b0000000000000000; gr[2] &lt;= 16&#x27;b0000000000000000; gr[3] &lt;= 16&#x27;b0000000000000000; gr[4] &lt;= 16&#x27;b0000000000000000; gr[5] &lt;= 16&#x27;b0000000000000000; gr[6] &lt;= 16&#x27;b0000000000000000; gr[7] &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state==`interrupt) begin if (wb_ir[10:8] != 3&#x27;b000) if ((wb_ir[15:11] == `LOAD) || (wb_ir[15:11] == `ADDI) || (wb_ir[15:11] == `SUBI) || (wb_ir[15:11] == `LDIH) || (wb_ir[15:11] == `ADD) || (wb_ir[15:11] == `CMP) || (wb_ir[15:11] == `ADDC) || (wb_ir[15:11] == `SUB) || (wb_ir[15:11] == `SUBC) || (wb_ir[15:11] == `AND) || (wb_ir[15:11] == `OR) || (wb_ir[15:11] == `XOR) || (wb_ir[15:11] == `SLL) || (wb_ir[15:11] == `SRL) || (wb_ir[15:11] == `SLA) || (wb_ir[15:11] == `SRA) || (wb_ir[15:11] == `LWC_ENCRYPT)) gr[wb_ir[10:8]] &lt;= reg_C1; else gr[wb_ir[10:8]] &lt;= gr[wb_ir[10:8]]; end end// ALU modulealways @(reg_A or reg_B or ex_ir[15:11]) case (ex_ir[15:11]) `LOAD : ALUo &lt;= reg_A + reg_B; `STORE : ALUo &lt;= reg_A + reg_B; `ADD : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; `CMP : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `BZ : ALUo &lt;= reg_A + reg_B; `BN : ALUo &lt;= reg_A + reg_B; //[------------- LUWEICHENG -------------] // Basic operations `ADDC : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B + cf; `SUB : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `SUBC : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B - cf; `ADDI : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; `SUBI : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `LDIH : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; // Logical/Shift operations `AND : begin ALUo &lt;= reg_A &amp; reg_B; cf &lt;= 1&#x27;b0; end `OR : begin ALUo &lt;= reg_A | reg_B; cf &lt;= 1&#x27;b0; end `XOR : begin ALUo &lt;= reg_A ^ reg_B; cf &lt;= 1&#x27;b0; end `SLL : begin ALUo &lt;= reg_A &lt;&lt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end `SRL : begin ALUo &lt;= reg_A &gt;&gt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end //[注]老版本iverilog编译器不认识&gt;&gt;&gt;和&lt;&lt;&lt;运算符，必须手动实现算数左右移。 2025.2.7 //`SLA : begin ALUo &lt;= reg_A &lt;&lt;&lt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end //`SRA : begin ALUo &lt;= reg_A &gt;&gt;&gt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end `SLA : begin if(reg_A[15] == 1&#x27;b1) ALUo &lt;= 16&#x27;h8000 | (reg_A &lt;&lt; reg_B[3:0]); //8000 = 1000_0000_0000_0000 else if(reg_A[15] == 1&#x27;b0) ALUo &lt;= 16&#x27;h7FFF &amp; (reg_A &lt;&lt; reg_B[3:0]); //7FFF = 0111_1111_1111_1111 else ALUo &lt;= 16&#x27;bx; end `SRA : begin if(reg_A[15] == 1&#x27;b1) ALUo &lt;= (&#123;16&#123;1&#x27;b1&#125;&#125; &lt;&lt; (16 - reg_B[3:0])) | (reg_A &gt;&gt; reg_B[3:0]); //(&#123;16&#123;1&#x27;b1&#125;&#125; &lt;&lt; (16 - reg_B[3:0]))生成高位全1的掩码 else if(reg_A[15] == 1&#x27;b0) ALUo &lt;= reg_A &gt;&gt; reg_B[3:0]; else ALUo &lt;= 16&#x27;bx; end `LWC_ENCRYPT: ALUo &lt;= &#123;reg_A[15:8]^reg_B[7:0], reg_A[7:4]^reg_B[11:8], reg_A[3:0]^reg_B[15:12]&#125;; // Control operations `JMPR : ALUo &lt;= reg_A + reg_B; `BNZ : ALUo &lt;= reg_A + reg_B; `BNN : ALUo &lt;= reg_A + reg_B; `BC : ALUo &lt;= reg_A + reg_B; `BNC : ALUo &lt;= reg_A + reg_B; //[------------- LUWEICHENG -------------] default : begin ALUo &lt;= ALUo; cf &lt;= cf; end endcase// Debugalways @(select_y or gr[1] or gr[2] or gr[3] or gr[4] or gr[5] or gr[6] or gr[7] or reg_A or reg_B or reg_C or reg_C1 or smdr or id_ir or dw or zf or nf or pc) begin case (select_y) 4&#x27;b0000 : y = &#123;3&#x27;b000, dw, 2&#x27;b00, zf, nf, pc&#125;; 4&#x27;b0001 : y = gr[1]; 4&#x27;b0010 : y = gr[2]; 4&#x27;b0011 : y = gr[3]; 4&#x27;b0100 : y = gr[4]; 4&#x27;b0101 : y = gr[5]; 4&#x27;b0110 : y = gr[6]; 4&#x27;b0111 : y = gr[7]; 4&#x27;b1000 : y = reg_A; 4&#x27;b1001 : y = reg_B; 4&#x27;b1011 : y = reg_C; 4&#x27;b1100 : y = reg_C1; 4&#x27;b1101 : y = smdr; 4&#x27;b1110 : y = id_ir; default : y = 16&#x27;bXXXXXXXXXXXXXXXX ; endcase endendmodule 代码（创新版：可以实现中断和回调）中断和回调的实现方法在报告中已经详细说明，这里直接粘贴报告中的文字描述和图片进行解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463`define NOP 5&#x27;b00000`define HALT 5&#x27;b00001`define LOAD 5&#x27;b00010`define STORE 5&#x27;b00011`define ADD 5&#x27;b01000`define CMP 5&#x27;b01100`define BZ 5&#x27;b11010`define BN 5&#x27;b11100//[------------- LUWEICHENG -------------]// Basic operations`define SUB 5&#x27;b01010`define SUBC 5&#x27;b10010`define ADDC 5&#x27;b10001`define ADDI 5&#x27;b01001`define SUBI 5&#x27;b01011`define LDIH 5&#x27;b10000// Logical/Shift operations`define AND 5&#x27;b01101`define OR 5&#x27;b01110`define XOR 5&#x27;b01111`define SLL 5&#x27;b00100`define SRL 5&#x27;b00101`define SLA 5&#x27;b00110`define SRA 5&#x27;b00111// Control operations`define JUMP 5&#x27;b11000`define JMPR 5&#x27;b11001`define BNZ 5&#x27;b11011`define BNN 5&#x27;b11101`define BC 5&#x27;b11110`define BNC 5&#x27;b11111 //** LWC original operations`define LWC_CLEAR 5&#x27;b10011 //clear: clear one data in rg[val3] 【CLEAR null null val3】`define LWC_CA 5&#x27;b10100 //CA: celete all data in rg 【no op1op2op3, like NOP &amp; HALT】`define LWC_ENCRYPT 5&#x27;b10101 //encrypt: 数据加密 【LWC_ENCRYPT r1 r2 r3】 秘钥：r3; 源码：r2；加密结果存放在r1，秘钥存放在r1+1.`define LWC_INTERRUPT 5&#x27;b10110 //Interrupt: 中断 (Control operation) `define LWC_CALLBACK 5&#x27;b10111 //CallBack: 中断回调//[------------- LUWEICHENG -------------]// FSM for CPU controler`define idle 2&#x27;b00`define exec 2&#x27;b01`define interrupt 2&#x27;b10module pcpu (reset, clock, enable, start, i_addr, i_datain, i_datain_interrupt, d_addr, d_datain, d_dataout, d_we, select_y, y);input reset, clock, enable, start; //由顶层于外部连接，由外部(仿真时)控制input [15:0] i_datain;input [15:0] i_datain_interrupt;output [7:0] i_addr;output [7:0] d_addr;input [15:0] d_datain;output [15:0] d_dataout;output d_we;// for Debug ------------ 只是用y看一下内部各个线上的数据input [3:0] select_y;output [15:0] y; // Definition of F/Fsreg [7:0] pc ; //pc: 取指令的指针，指向imem内下一条要执行的指令。reg [15:0] id_ir, ex_ir, mem_ir, wb_ir; //xx_ir: 指令链，不同阶段对指令instruction进行流水线式的存储。reg [15:0] gr [0:7]; //gr: General Register。它是CPU内部的存储器(寄存器堆)。reg [15:0] reg_A, reg_B, reg_C, reg_C1; //reg_X: 数据寄存器，用于CPU内部运算数据的暂存。 [reg_A,reg_B] --&gt; ALU --&gt; [reg_C]reg [15:0] smdr, smdr1; //smdr: 直接存储数据reg zf, nf, dw; //flags: zf(zero flag); nf(negative flag); dw(data write):与d_we相连，是CPU-&gt;dmem写使能。//[------------- LUWEICHENG -------------]reg cf; //carry flag: 进位信号reg[7:0] pc_interrupt; //记录中断前的pc值，中断回调后pc置为 pc_interrupt+1reg inter_flag;//[------------- LUWEICHENG -------------]reg[1:0] state;// Definition of temporary variablesreg [15:0] ALUo;reg [15:0] y;reg[1:0] next_state;assign i_addr = pc; //pc给到i_addr，i_addr输出到imem，取出一条指令assign d_we = dw;assign d_addr = reg_C[7:0]; //从dmem中取data的地址，地址始终存在reg_C中assign d_dataout = smdr1;// CPU Control (FSM)always @(posedge clock or negedge reset) begin if (!reset) state &lt;= `idle; else state &lt;= next_state; endalways @(state or enable or start or wb_ir[15:11]) begin case (state) `idle : if ((enable == 1&#x27;b1) &amp;&amp; (start == 1&#x27;b1)) next_state &lt;= `exec; else next_state &lt;= `idle; `exec : if ((enable == 1&#x27;b0) || (wb_ir[15:11] == `HALT)) next_state &lt;= `idle; else if ((enable == 1&#x27;b0) || (id_ir[15:11] == `LWC_INTERRUPT)) next_state &lt;= `interrupt; else next_state &lt;= `exec; `interrupt: if (id_ir[15:11] == `LWC_CALLBACK) next_state &lt;= `exec; else next_state &lt;= `interrupt; endcase end // IF Block (1st Stage)always @(posedge clock or negedge reset) begin if (!reset) begin id_ir &lt;= 16&#x27;b0000000000000000; pc &lt;= 8&#x27;b00000000; pc_interrupt &lt;= 8&#x27;b00000000; inter_flag &lt;= 0; end else if(state==`exec||state==`interrupt) begin // id_ir &lt;= i_datain; //从imem取指令 id_ir &lt;= (state == `interrupt) ? i_datain_interrupt : i_datain; //主要任务：pc指针控制 if ( ((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1)) || (mem_ir[15:11] == `JMPR) || ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0)) || ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0)) || ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0)) ) //特殊指令跳转： jump to reg_C[7:0]，跳转到ALU运算出来的指令地址。 pc &lt;= reg_C[7:0]; else if (id_ir[15:11] == `JUMP) //JUMP指令跳转: jump to &#123;val2,val3&#125;, 中括号的意思是[7:4]与[3:0]组合为[7:0] pc &lt;= id_ir[7:0]; //[------------- LUWEICHENG -------------] //interrupt &amp; callback else if (id_ir[15:11] == `LWC_INTERRUPT) begin pc &lt;= 0; //转到imem_interrupt,从0开始 if(inter_flag == 0) begin pc_interrupt &lt;= pc; //记录中断前的pc值 inter_flag &lt;= 1; end end else if (id_ir[15:11] == `LWC_CALLBACK) begin pc &lt;= pc_interrupt; //回到imem end //[------------- LUWEICHENG -------------] else pc &lt;= pc + 1; end else if(state==`idle) //pc停止 pc &lt;= pc; else ; end // ID Block (2nd Stage)always @(posedge clock or negedge reset)begin if (!reset) begin ex_ir &lt;= 16&#x27;b0000000000000000; reg_A &lt;= 16&#x27;b0000000000000000; reg_B &lt;= 16&#x27;b0000000000000000; smdr &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state==`interrupt) begin ex_ir &lt;= id_ir; //ir传递（id -&gt; ex） //[------------- LUWEICHENG -------------] //The general register clearing operations LWC_CLEAR and LWC_CA are executed //directly in the ID stage, no need to wait until the WB if (id_ir[15:11] == `LWC_CA) begin gr[0] = 16&#x27;b0000000000000000; gr[1] = 16&#x27;b0000000000000000; gr[2] = 16&#x27;b0000000000000000; gr[3] = 16&#x27;b0000000000000000; gr[4] = 16&#x27;b0000000000000000; gr[5] = 16&#x27;b0000000000000000; gr[6] = 16&#x27;b0000000000000000; gr[7] = 16&#x27;b0000000000000000; end else if (id_ir[15:11] == `LWC_CLEAR) begin //clear: clear one data in rg[val3] 【CLEAR null null val3】 gr[id_ir[3:0]] = 16&#x27;b0000000000000000; end else ; //[------------- LUWEICHENG -------------] /******************** reg_A 赋予：第一个操作数 *************************************************************************************************************** *********************/ //↓[type:I] r1 val2 val3 形 if ((id_ir[15:11] == `ADDI) || (id_ir[15:11] == `SUBI) || (id_ir[15:11] == `LDIH) || (id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[10:8] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) //无目的寄存器(operand1 = null) reg_A &lt;= ((id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) ? gr[(id_ir[10:8])]: ALUo; else if ((id_ir[10:8] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_A &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[10:8] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_A &lt;= reg_C1; else reg_A &lt;= gr[(id_ir[10:8])]; //取出r1 ############# end //[------------- LUWEICHENG -------------] //↓[type:R] r1 r2 r3 形 else if ((id_ir[15:11] == `LOAD) || (id_ir[15:11] == `STORE) || (id_ir[15:11] == `ADD) || (id_ir[15:11] == `CMP) || (id_ir[15:11] == `ADDC) || (id_ir[15:11] == `SUB) || (id_ir[15:11] == `SUBC) || (id_ir[15:11] == `AND) || (id_ir[15:11] == `OR) || (id_ir[15:11] == `XOR) || (id_ir[15:11] == `SLL) || (id_ir[15:11] == `SRL) || (id_ir[15:11] == `SLA) || (id_ir[15:11] == `SRA) || (id_ir[15:11] == `LWC_ENCRYPT)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[6:4] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) reg_A &lt;= ALUo; else if ((id_ir[6:4] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_A &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[6:4] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_A &lt;= reg_C1; else //[------------- LUWEICHENG -------------] reg_A &lt;= gr[(id_ir[6:4])]; //取出r2 ############# end else if (((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0))|| ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0))|| ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0))|| mem_ir[15:11] == `JMPR) reg_A &lt;= 16&#x27;b0000_0000_0000_0000; else ; /********************* reg_B赋予：第二个操作数*************************************************************************************************************** ******************** */ if (id_ir[15:11] == `LOAD) reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //val3 ############# else if (id_ir[15:11] == `STORE) begin reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //[------------- LUWEICHENG -------------] //smdr的赋值也需要：hazard 避免 if ((id_ir[10:8] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) smdr &lt;= ALUo; else if ((id_ir[10:8] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) smdr &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[10:8] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) smdr &lt;= reg_C1; else //[------------- LUWEICHENG -------------] smdr &lt;= gr[id_ir[10:8]]; //STORE ############# end else if ((id_ir[15:11] == `SLL) || (id_ir[15:11] == `SRL) || (id_ir[15:11] == `SLA) || (id_ir[15:11] == `SRA)) reg_B &lt;= &#123;12&#x27;b000000000000, id_ir[3:0]&#125;; //r1,r2,val3形：只取val3,需要在前面补12位0 ########### else if ((id_ir[15:11] == `ADDI) || (id_ir[15:11] == `SUBI) || (id_ir[15:11] == `BZ) || (id_ir[15:11] == `BN) || (id_ir[15:11] == `JMPR) || (id_ir[15:11] == `BNZ) || (id_ir[15:11] == `BNN) || (id_ir[15:11] == `BC) || (id_ir[15:11] == `BNC)) reg_B &lt;= &#123;8&#x27;b00000000, id_ir[7:0]&#125;; // r1 val2 val3, 取出&#123;val2,val3&#125;的组合,需要在前面补8位0 ########### else if (id_ir[15:11] == `LDIH) reg_B &lt;= &#123;id_ir[7:0], 8&#x27;b00000000&#125;; //LDIH较为特殊，取出&#123;val2,val3&#125;的组合后，在后面补8个0 ########### else if ((id_ir[15:11] == `ADD) || (id_ir[15:11] == `CMP) || (id_ir[15:11] == `ADDC) || (id_ir[15:11] == `SUB) || (id_ir[15:11] == `SUBC) || (id_ir[15:11] == `AND) || (id_ir[15:11] == `OR) || (id_ir[15:11] == `XOR) || (id_ir[15:11] == `LWC_ENCRYPT)) begin //[------------- LUWEICHENG -------------] // hazard 避免 if ((id_ir[2:0] == ex_ir[10:8]) &amp;&amp; (ex_ir[15:11]!=`NOP) &amp;&amp; (ex_ir[15:11]!=`CMP) &amp;&amp; (ex_ir[15:11]!=`JUMP) &amp;&amp; (ex_ir[15:11]!=`LOAD) &amp;&amp; (ex_ir[15:11]!=`HALT)) reg_B &lt;= ALUo; else if ((id_ir[2:0] == mem_ir[10:8]) &amp;&amp; (mem_ir[15:11]!=`NOP) &amp;&amp; (mem_ir[15:11]!=`CMP) &amp;&amp; (mem_ir[15:11]!=`JUMP) &amp;&amp; (mem_ir[15:11]!=`HALT)) reg_B &lt;= (mem_ir[15:11] == `LOAD) ? d_datain : reg_C; else if ((id_ir[2:0] == wb_ir[10:8]) &amp;&amp; (wb_ir[15:11]!=`NOP) &amp;&amp; (wb_ir[15:11]!=`CMP) &amp;&amp; (wb_ir[15:11]!=`JUMP) &amp;&amp; (wb_ir[15:11]!=`HALT)) reg_B &lt;= reg_C1; else // r1 r2 r3，取出r3； ############# reg_B &lt;= gr[id_ir[2:0]]; //[------------- LUWEICHENG -------------] end else if (((mem_ir[15:11] == `BZ) &amp;&amp; (zf == 1&#x27;b1)) || ((mem_ir[15:11] == `BN) &amp;&amp; (nf == 1&#x27;b1))|| ((mem_ir[15:11] == `BNZ) &amp;&amp; (zf == 1&#x27;b0)) || ((mem_ir[15:11] == `BNN) &amp;&amp; (nf == 1&#x27;b0))|| ((mem_ir[15:11] == `BC) &amp;&amp; (cf == 1&#x27;b1)) || ((mem_ir[15:11] == `BNC) &amp;&amp; (cf == 1&#x27;b0))|| mem_ir[15:11] == `JMPR) reg_B &lt;= 16&#x27;b0000_0000_0000_0000; else ; endend // EX Block (3rd Stage)always @(posedge clock or negedge reset) begin if (!reset) begin mem_ir &lt;= 16&#x27;b0000000000000000; reg_C &lt;= 16&#x27;b0000000000000000; smdr1 &lt;= 16&#x27;b0000000000000000; zf &lt;= 1&#x27;b0 ; nf &lt;= 1&#x27;b0 ; dw &lt;= 1&#x27;b0 ; end else if(state==`exec||state==`interrupt) begin mem_ir &lt;= ex_ir; reg_C &lt;= ALUo; //reg_C转存ALUo运算结果 smdr1 &lt;= smdr; //flag更新 if ((ex_ir[15:11] == `ADDI) || (ex_ir[15:11] == `SUBI) || (ex_ir[15:11] == `LDIH) || (ex_ir[15:11] == `ADD) || (ex_ir[15:11] == `CMP) || (ex_ir[15:11] == `ADDC) || (ex_ir[15:11] == `SUB) || (ex_ir[15:11] == `SUBC) || (ex_ir[15:11] == `AND) || (ex_ir[15:11] == `OR) || (ex_ir[15:11] == `XOR) || (ex_ir[15:11] == `SLL) || (ex_ir[15:11] == `SRL) || (ex_ir[15:11] == `SLA) || (ex_ir[15:11] == `SRA)) begin if (ALUo == 16&#x27;b0000000000000000) zf &lt;= 1&#x27;b1; else zf &lt;= 1&#x27;b0; if (ALUo [15] == 1&#x27;b1) nf &lt;= 1&#x27;b1; else nf &lt;= 1&#x27;b0; end if (ex_ir[15:11] == `STORE) begin dw &lt;= 1&#x27;b1; //smdr1 &lt;= smdr; end else dw &lt;= 1&#x27;b0; end end // MEM Block (4th Stege)always @(posedge clock or negedge reset) begin if (!reset) begin wb_ir &lt;= 16&#x27;b0000000000000000; reg_C1 &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state == `interrupt) begin wb_ir &lt;= mem_ir; if (mem_ir[15:11] == `LOAD) //**** `LOAD回路：从dmem取得的数据在d_datain中，先给到reg_C1,然后转存到cpu内部存储gr。程序运行其他操作时，时再从gr取数据。 //其实reg_C一直作为dmem的地址索引，但只有LOAD指令时，cpu才会从dmem中取出数据存入regC_1；其余时候reg_C1转存运算结果reg_C。 reg_C1 &lt;= d_datain; else reg_C1 &lt;= reg_C; end end // WB Block (5th Stage)always @(posedge clock or negedge reset) begin if (!reset) begin gr[0] &lt;= 16&#x27;b0000000000000000; gr[1] &lt;= 16&#x27;b0000000000000000; gr[2] &lt;= 16&#x27;b0000000000000000; gr[3] &lt;= 16&#x27;b0000000000000000; gr[4] &lt;= 16&#x27;b0000000000000000; gr[5] &lt;= 16&#x27;b0000000000000000; gr[6] &lt;= 16&#x27;b0000000000000000; gr[7] &lt;= 16&#x27;b0000000000000000; end else if(state==`exec||state==`interrupt) begin if (wb_ir[10:8] != 3&#x27;b000) if ((wb_ir[15:11] == `LOAD) || (wb_ir[15:11] == `ADDI) || (wb_ir[15:11] == `SUBI) || (wb_ir[15:11] == `LDIH) || (wb_ir[15:11] == `ADD) || (wb_ir[15:11] == `CMP) || (wb_ir[15:11] == `ADDC) || (wb_ir[15:11] == `SUB) || (wb_ir[15:11] == `SUBC) || (wb_ir[15:11] == `AND) || (wb_ir[15:11] == `OR) || (wb_ir[15:11] == `XOR) || (wb_ir[15:11] == `SLL) || (wb_ir[15:11] == `SRL) || (wb_ir[15:11] == `SLA) || (wb_ir[15:11] == `SRA) || (wb_ir[15:11] == `LWC_ENCRYPT)) gr[wb_ir[10:8]] &lt;= reg_C1; else gr[wb_ir[10:8]] &lt;= gr[wb_ir[10:8]]; end end// ALU modulealways @(reg_A or reg_B or ex_ir[15:11]) case (ex_ir[15:11]) `LOAD : ALUo &lt;= reg_A + reg_B; `STORE : ALUo &lt;= reg_A + reg_B; `ADD : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; `CMP : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `BZ : ALUo &lt;= reg_A + reg_B; `BN : ALUo &lt;= reg_A + reg_B; //[------------- LUWEICHENG -------------] // Basic operations `ADDC : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B + cf; `SUB : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `SUBC : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B - cf; `ADDI : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; `SUBI : &#123;cf,ALUo&#125; &lt;= reg_A - reg_B; `LDIH : &#123;cf,ALUo&#125; &lt;= reg_A + reg_B; // Logical/Shift operations `AND : begin ALUo &lt;= reg_A &amp; reg_B; cf &lt;= 1&#x27;b0; end `OR : begin ALUo &lt;= reg_A | reg_B; cf &lt;= 1&#x27;b0; end `XOR : begin ALUo &lt;= reg_A ^ reg_B; cf &lt;= 1&#x27;b0; end `SLL : begin ALUo &lt;= reg_A &lt;&lt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end //reg_B[3:0]存放的是val3，也就是ir[3:0] `SRL : begin ALUo &lt;= reg_A &gt;&gt; reg_B[3:0]; cf &lt;= 1&#x27;b0; end `SLA : begin if(reg_A[15] == 1&#x27;b1) ALUo &lt;= 16&#x27;h8000 | (reg_A &lt;&lt; reg_B[3:0]); //8000 = 1000_0000_0000_0000 else if(reg_A[15] == 1&#x27;b0) ALUo &lt;= 16&#x27;h7FFF &amp; (reg_A &lt;&lt; reg_B[3:0]); //7FFF = 0111_1111_1111_1111 else ALUo &lt;= 16&#x27;bx; end `SRA : begin if(reg_A[15] == 1&#x27;b1) ALUo &lt;= (&#123;16&#123;1&#x27;b1&#125;&#125; &lt;&lt; (16 - reg_B[3:0])) | (reg_A &gt;&gt; reg_B[3:0]); //(&#123;16&#123;1&#x27;b1&#125;&#125; &lt;&lt; (16 - reg_B[3:0]))生成高位全1的掩码 else if(reg_A[15] == 1&#x27;b0) ALUo &lt;= reg_A &gt;&gt; reg_B[3:0]; else ALUo &lt;= 16&#x27;bx; end `LWC_ENCRYPT: ALUo &lt;= &#123;reg_A[15:8]^reg_B[7:0], reg_A[7:4]^reg_B[11:8], reg_A[3:0]^reg_B[15:12]&#125;; // Control operations `JMPR : ALUo &lt;= reg_A + reg_B; `BNZ : ALUo &lt;= reg_A + reg_B; `BNN : ALUo &lt;= reg_A + reg_B; `BC : ALUo &lt;= reg_A + reg_B; `BNC : ALUo &lt;= reg_A + reg_B; //[------------- LUWEICHENG -------------] default : begin ALUo &lt;= ALUo; cf &lt;= cf; end endcase// Debugalways @(select_y or gr[1] or gr[2] or gr[3] or gr[4] or gr[5] or gr[6] or gr[7] or reg_A or reg_B or reg_C or reg_C1 or smdr or id_ir or dw or zf or nf or pc) begin case (select_y) 4&#x27;b0000 : y = &#123;3&#x27;b000, dw, 2&#x27;b00, zf, nf, pc&#125;; 4&#x27;b0001 : y = gr[1]; 4&#x27;b0010 : y = gr[2]; 4&#x27;b0011 : y = gr[3]; 4&#x27;b0100 : y = gr[4]; 4&#x27;b0101 : y = gr[5]; 4&#x27;b0110 : y = gr[6]; 4&#x27;b0111 : y = gr[7]; 4&#x27;b1000 : y = reg_A; 4&#x27;b1001 : y = reg_B; 4&#x27;b1011 : y = reg_C; 4&#x27;b1100 : y = reg_C1; 4&#x27;b1101 : y = smdr; 4&#x27;b1110 : y = id_ir; default : y = 16&#x27;bXXXXXXXXXXXXXXXX ; endcase endendmodule","categories":[{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"},{"name":"System LSI Design","slug":"Course-Assignment/System-LSI-Design","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/System-LSI-Design/"}],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"https://shinononome-enana.github.io/tags/Verilog/"}]},{"title":"四国跨年之旅：2024.12.27~2025.1.3","slug":"2025travel","date":"2025-01-03T13:08:15.000Z","updated":"2025-01-04T08:01:18.038Z","comments":true,"path":"2025/01/03/2025travel/","permalink":"https://shinononome-enana.github.io/2025/01/03/2025travel/","excerpt":"","text":"前言2024-2025是我来日本留学后的第一个新年(跨年)，正好这会儿学校放冬假，我便计划想去哪里玩一下。一开始本来打算和实验室的其他几位同学去东京跨年，但是我们酒店订太晚了，东京12.31-1.1的跨年夜酒店最便宜的一晚上都要一千五六百RMB,实在是无法接受，于是大家就散了他们去长崎看芙莉莲了……后来舍友曹桑提议去宫岛上玩儿，说是学姐推荐，但找了半天也不知道在哪儿，后来也不知道什么原因我突然说可以去“四国”看看，后来就这么拍定了。 启程：新門司 → 徳島 (東九フェーリ)我和舍友两人一人各背一个双肩包，轻装上阵，12.27从宿舍出发一路赶到北九州市的最北边“新门司港”，乘坐轮渡前往四国，12.28计划到达四国最东边城市“德岛市”。 门司港是连通九州和中国地区的繁忙港口，而我们要去的新门司港则是稍靠东南方向的一个港口，主要通行九州到四国、东京和北海道的船。当我们坐了一路电车到达新门司港后，发现这里的风景还算不错。 我们乘坐的轮渡虽然叫“東九フェーリ”，但其实是北九州-德岛-东京三个港口之间的航线，因此会在德岛的港口停靠。这样，我们12.28日就能从德岛出发，沿着“土赞线”一路西行，然后北上前往高松市和再北边的几个岛屿（丰岛、直岛和小豆岛）。我们本来还打算从小仓乘坐轮渡前往四国西边的松山市，因为松山离北九州更近一些，这样的话我们可以从松山出发一路北上游玩整个四国北部，但可惜的是年前的二等和一等席全都满席了……我们还考虑过坐新干线，但坐JR并不比轮渡便宜，而且坐电车已经做腻了，坐轮船对于我们而言还是个全新的体验。因此，最后我们还是选择了東九フェーリ。 事实证明，我们的选择是正确的，東九フェーリ给我们乘坐的体验相当好。我们订的房间是8人间二等洋式，但因为人少所以我和舍友直接包场！船在航行的过程中能感受到发动机连同整个船体在震动，而且能感受到船的左右晃动，但不影响基本的吃饭和睡觉。東九フェーリ甚至还配备了一个温泉，泡澡的同时可以通过舷窗欣赏海景（虽然晚上看不到什么只能看到远处陆地上的灯光orz）。 船的露天甲板也是可以上的。我和舍友特意在6:00早起，然后到甲板上去看海上的日出了。虽然甲板上风大了一点，但是这样美妙的日出景色还是让我们在寒风中站了许久。当然也可以在温暖的船舱内一边吃早饭一边看 12.28：徳島市和美马市由于轮渡在早上九点就抵达了，距离我们下午三点check in美马市的民宿还有一段时间，我们就先在JR德岛站边上的德岛公园转了转。 这里似乎是德岛市民的健身圣地，公园里有很多在跑步的男女老少（绕公园一圈貌似是5公里，我上能跑两圈）。德岛公园是一个完全开放的公园，严格意义讲也算不上是一个旅游景点，但这里面风景倒是很棒。池塘里有小鸭子，繁茂的花草树木间还有很多鸽子，它们一点也不怕人，除非你要踩到它们它们才肯飞走；虽然已经是冬天了，公园里仍有几棵红叶点缀在翠绿的松树之间，显得格外的好看。 随后我们就直接前往美马市的民宿了，我们乘坐的是德岛线前往四国中央的山区里。JR四国非常原始，电车比我想象中的还要老式，站台内居然没有自动检票的改札口，必须人工检票，而且下车时需要在前门给车长检票，和公交车一样！而且听这电车的发动机声音貌似不是电驱动的，而且和公交车一样是常规的柴油发动机！ 四国山脉的壮丽程度远远超过我的预想。电车穿行在山岭里，山间随处可见小小的村落；电车靠近城市后眼界逐渐开阔，此时便能看到远处连绵的山脉了。云雾缭绕在半山腰，靠近山顶的部分便都是积雪了。由于是阴天的缘故，整座山仿佛笼罩着一层薄薄的雾气，加之山间时而显现的村落，便显得格外神秘。 美马市座落在山脉里，这里的居民很少，街道上显得有些破败或者说有点凄凉，但是竟然有麦当劳和帕青哥。街道上虽然有很多来往的车辆，但也大都只是从德岛前往松山途径这里而已，不会停留。吉野川横穿了这座城市。我们的民宿在山上，爬山的时候要经过一个小神社。 12.29 大小步危从美马市前往大小步危则需要向西南方向更加深入山脉。首先还是坐JR德岛线到终点站“阿波池田”，这里也是一个小镇，但让人感觉比美马市繁华多了。从站台眺望的风景能同时看到电车和山脉，很美；站台边上还有一个小公园，有种梦核的感觉？ 大小步危是大步危和小步危。我们先在大步危坐了游览船，游船行驶在碧清的河道上，两侧则是几千年来冲刷而成的山谷峭壁；两座山之间是不是会出现一座大桥连通，左边山崖上是是盘山公路，右边则是JR山藏线。 后来我们北上徒步到小步危，中途还去吃了个大步危特色そば。我们在大步危泡了温泉，700日元一个人的价格实在是太实惠了。温泉水温暖了早已被寒风冻僵的四肢，在泡温泉的同时还能够欣赏雪山的美景，山间时不时还有电车穿行而过，这样的场景简直美得让人窒息！这样的机会恐怕很难再有了吧……直到天色渐黑，我们才做JR山藏线和琴電（ことでん）从小步危返回阿波池田，随后前往高松市。 走在昏暗的山间，身边雾气缭绕，我感到整个世界都不真实了，仿佛置身于梦境中，下一秒随时可能会醒来…… 12.30 高松市高松市本来只是作为我们前往小豆岛的一个中继点，但事实上高松给了我很好的印象住了两晚。在休息了一夜后，我们花了一个上午在栗林公園闲逛，栗林公園是高松古代君主模仿苏州园林建造的一个园林，里面的景色非常优美。 高松还有全日本最长的商业街名字忘了，里面非常热闹繁华在里面打了舞萌。我在里面连续吃了两天的松屋猪排饭，便宜量大！ 在傍晚时分，我们前往高松港提前打探轮渡的消息，却正巧碰到了港口绝美的夕阳景色！远处的海平线上群山起伏，山后则氤氲着艳丽的红色晚霞，晚霞的红和天空的蓝交融在了一起。港口有正在缓缓驶来的轮船，天空中时不时飞过成群的海鸥……这样的景色是只有通过双眼才能感受到的真实。 在天色完全黑下来之后，我们登上高松的标志性建筑，在顶楼观赏了高松市城区和高松港美丽的夜景。 12.31~1.1 在小豆岛的跨年之夜我们从昨晚的高松港坐高速艇，半小时就到了小豆岛的土庄港。映入眼帘的就是“高木同学”的海报！酒店check in之前我们先在岛上随便逛了逛，去了妖怪博物馆票价2900日元非常昂贵，还去了著名景点天使的散步路。 在跨年的夜晚，岛上几乎所有店全都休业了，即便是还开着的店也需要提前预约。饥肠辘辘的我和舍友在寒风中走了许久，最后还是决定吃便利店了……于是，我们在日本的第一个跨年夜晚餐，便是711大餐orz。虽然有些囧，但这种体验非常奇妙。我们还把电视机打开看了NHK的红白歌会，也算是看日本春晚入乡随俗了。 1.1新年一大早我们便起床去附近的八幡神社，完成新年的第一次参拜（初詣：はつもうで）。奉纳完之后去抽了おみくじ，我只抽到了末吉，神签上告诉我这一年会遇到诸多不顺，但如果努力去做的话仍然可以挽回。它告诫我需要通过自身的努力去达成目标，也算是给了我一些告诫和鼓励。当然这个结果并不是很好但至少不是凶，所以我把这个签系在了神社的树上，希望神明能够助我一臂之力；舍友的运气很好，又一次抽到了大吉。 后来我们二人租了一个电助力自行车带电的哈啰共享单车沿着海岸线环游了小豆岛。途中正好发现了一座可以攀爬的山，误打误撞地也是完成了新年的第一次登高不知道日本有没有新年登高的习俗。山顶上有一个用木头搭起来的鸟居，里面的巨石叫做“重岩”。从山顶可以俯瞰小豆岛的海景，还能看到海平线远处连绵起伏的山脉，令人心旷神怡。 后来，我们还骑到了一个种着很多棕榈树的沙滩边。这是一个地图上没有标出来的沙滩，几乎没有人造访这里，但是这里的景色意外的好，我们也是在这里停留了许久。 再后来我们路过了“鹿岛明神社”，里面都是来圣地巡礼高木同学的人！这让我决定回家补一补这一部番。 在这之后就没干啥了，吃了个饭继续骑行环游小豆岛，然后回到土庄港坐轮船回到高松。在离开小豆岛之前，我们稍微逛了一下土庄港，发现了著名地标“太阳的礼物”我记得高木同学有一季的海报就是这儿?。 1.2 松山市其实一开始我们并没有打算来松山，准备直接从高松飞回北九州。但最后我们还是预定了松山到小仓的フェーリ，打算最后再坐一次船，因此不得不前往四国最西端的松山市了。从高松到松山横跨整个四国，路途极为遥远，但好在我们赶上了两市之间直通的高速巴士。 在松山休息了一晚后，我们去了最著名景点的松山城，里面是古代四国君主建造的天守阁，地势非常的高，可以俯瞰整个管辖地区。前往松山城可以做单人缆车，我们也体验了一把。由于是新年，这一天松山城里还举办了日本传统的“打年糕”活动，我也是第一次近距离观看，非常热闹有意思。 由于松山-小仓フェーリ晚上十一点才发船，为了消磨时间我们还去了很多地方。比如顺路参拜了一下东云神社这里的御朱印免费！，一路向着港口方向暴走，然后顺路逛了逛book-off买了几本漫画，还去了趟电影院最后没看成电影。我们还去了爱媛大学和松山大学，它们是挨在一起的两所大学，不过貌似爱媛大学要比松山大学好得多。 返程：松山 → 小倉返程的フェーリ次日5点就抵达了，因此在船上停留的时间不长，船内体验也完全不如启程时的東九フェーリ船票反而贵了一倍！。 后记","categories":[{"name":"Life in Japan","slug":"Life-in-Japan","permalink":"https://shinononome-enana.github.io/categories/Life-in-Japan/"}],"tags":[{"name":"travel","slug":"travel","permalink":"https://shinononome-enana.github.io/tags/travel/"}]},{"title":"Opencv图像骨干提取算法的实现和优化 Thinning Algorithm (VSP Project)","slug":"opencv-VSP-thinning","date":"2024-12-13T09:04:07.000Z","updated":"2025-01-03T13:06:47.368Z","comments":true,"path":"2024/12/13/opencv-VSP-thinning/","permalink":"https://shinononome-enana.github.io/2024/12/13/opencv-VSP-thinning/","excerpt":"","text":"什么是骨干提取（教案） 代码总体框架 骨干提取Thinning： 骨干提取主函数：SequentialThinning。 自研骨干提取算法：solve，配合三个检查函数“CheckEdge,CheckConnectivity和CheckEndPoint”。 Zhang-suen骨干提取算法：zhangsuen_solve，配合两个检查函数“UpDownCheck和LeftRightCheck”。 特征点提取Feature Extraction： FeatureExtraction：配合四个检查函数。新增Check_3BranchPoint和Check_4BranchPoint。 提取后图像优化Optimization： removeLinesUseFeatureExtraction: 利用特征点进行优化，配合ColorPixelDetect。 12345678910111213141516171819202122class LWCThinning&#123; public: Mat SequentialThinning(Mat&amp; Image, int num_iterations); Mat FeatureExtraction(Mat&amp; Image); //Optimization Mat removeLinesUseFeatureExtraction(Mat&amp; Image); private: //VSP-slice based thinning Mat solve(Mat&amp; Image, int iter_time); int CheckEdge(Mat&amp; image3x3); int CheckConnectivity(Mat&amp; image3x3); int CheckEndPoint(Mat&amp; image3x3); //zhang-suen algorithm Mat zhangsuen_solve(Mat&amp; Image, int iter_time); int UpDownCheck(Mat&amp; image3x3); int LeftRightCheck(Mat&amp; image3x3); //Optimization functions int ColorPixelDetect(Mat&amp; image3x3); //Pixel Analyze int Check_3BranchPoint(Mat&amp; image3x3); int Check_4BranchPoint(Mat&amp; image3x3);&#125;; 时间复杂度上的考虑本代码中除了对原始图像的遍历使用了双重for循环，在其他方法中对3x3的卷积核进行处理时，均没有使用for循环。这是出于时间复杂度上的考量。3x3的卷积核很小，一共也才9个元素，如果再用一个常规的双重for循环进行处理，时间复杂度将会增加O(n^2)，与外部遍历结合起来就是O(n^4),处理大图片将会非常缓慢；但相对地，如果将其展开书写，将时间复杂度降低为O(1)的情况下代码也不会变得过于冗杂。 三次判断总体思路：三个check方法返回0或1。在solve()中调用这些check，三次判断全1才会执行像素的删除。 return 0: 该项check不通过，不可以删除。 return 1: 该项check通过，可以删除。 连续性判断 CheckConnectivity先说结论：判断中心注目像素周围一圈的八个像素，从一个节点开始顺时针旋转遍历。如果像素值“从黑转变为白”的次数超过1次，那么就是不连续的。（另外，前提是周围一圈有两个及以上的黑色像素。如果只有一个黑像素，那么这个中心像素就是端点end-point） 我们可以通过画图来探索这个规律： ①很好地展示了斜线连续性被破坏的情况。 ③很好地展示了直线连续性被破坏的情况。 ⑤展示了两条直线交点处连续性被破坏的情况。 ②中即便删除了中心像素，其连续性没有被破坏。 观察上述所有破快连续性的情况，我们发现他们周围一圈像素从黑变白的转变次数都大于一。(图中红色箭头和数字) 1234567891011121314151617181920212223242526int LWCThinning::CheckConnectivity(Mat&amp; image3x3)&#123; //======== iff time which around 8-pixel transfer from B to W is only 1, then it will have connectivity. ======== int B = 0; if(image3x3.at&lt;uchar&gt;(0,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(0,1) == 0) B++; if(image3x3.at&lt;uchar&gt;(0,2) == 0) B++; if(image3x3.at&lt;uchar&gt;(1,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(1,2) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,1) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,2) == 0) B++; int T = 0; //transfer from B to W if(image3x3.at&lt;uchar&gt;(0,2) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(0,1) == 255) T++; if(image3x3.at&lt;uchar&gt;(0,1) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(0,0) == 255) T++; if(image3x3.at&lt;uchar&gt;(0,0) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(1,0) == 255) T++; if(image3x3.at&lt;uchar&gt;(1,0) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(2,0) == 255) T++; if(image3x3.at&lt;uchar&gt;(2,0) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(2,1) == 255) T++; if(image3x3.at&lt;uchar&gt;(2,1) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(2,2) == 255) T++; if(image3x3.at&lt;uchar&gt;(2,2) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(1,2) == 255) T++; if(image3x3.at&lt;uchar&gt;(1,2) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(0,2) == 255) T++; if(B &gt;= 2 &amp;&amp; T == 1) return 1; //preserve connectivity else return 0;&#125; 端点判断 CheckEndPoint不难发现，如果中心注目像素的周围只存在一个黑色像素，那么它就是端点end-point。我们不能删除端点像素。 1234567891011121314151617int LWCThinning::CheckEndPoint(Mat&amp; image3x3)&#123; //======== iff around 8-pixel only have one B, then this center pixel is endpoint.======== int B = 0; if(image3x3.at&lt;uchar&gt;(0,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(0,1) == 0) B++; if(image3x3.at&lt;uchar&gt;(0,2) == 0) B++; if(image3x3.at&lt;uchar&gt;(1,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(1,2) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,0) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,1) == 0) B++; if(image3x3.at&lt;uchar&gt;(2,2) == 0) B++; if(B == 1) return 0; else return 1; //not end point&#125; 孤立点判断 CheckEdge这个是最简单的，只需要查看周围一圈是否有黑色像素即可。它的深层含义是：画面上孤立的黑色像素点不能删去，因为他完整地表征着一部分的画面信息。 12345678int LWCThinning::CheckEdge(Mat&amp; image3x3)&#123; if(image3x3.at&lt;uchar&gt;(0,0) == 0 || image3x3.at&lt;uchar&gt;(0,1) == 0 || image3x3.at&lt;uchar&gt;(0,2) == 0 || image3x3.at&lt;uchar&gt;(1,0) == 0 || image3x3.at&lt;uchar&gt;(1,2) == 0 || image3x3.at&lt;uchar&gt;(2,0) == 0 || image3x3.at&lt;uchar&gt;(2,1) == 0 || image3x3.at&lt;uchar&gt;(2,2) == 0 ) return 1; //boundary have B-pixel else return 0;&#125; slove()主方法 和 SequentialThinning()接口方法 使用3x3的卷积核遍历原始图像。具体而言，当检测到3x3的中心是黑色像素时，从原图中抽取这个3x3的正方形像素区域构成一个新图像kernel_nowscanning，然后进行三次check。如果check通过，则将中心的黑色像素删除（即变为白色）。 12345678910111213141516171819202122232425262728293031323334353637383940Mat LWCThinning::solve(Mat&amp; Image, int iter_time)&#123; int img_width = Image.size().width; int img_height = Image.size().height; for(int y = 1; y &lt; img_height-1; y++)&#123; for(int x = 1; x &lt; img_width-1; x++)&#123; Mat kernel_nowscanning = Mat::zeros(3,3,CV_8UC1); kernel_nowscanning.at&lt;uchar&gt;(0,0) = Image.at&lt;uchar&gt;(y-1,x-1); kernel_nowscanning.at&lt;uchar&gt;(0,1) = Image.at&lt;uchar&gt;(y-1,x); kernel_nowscanning.at&lt;uchar&gt;(0,2) = Image.at&lt;uchar&gt;(y-1,x+1); kernel_nowscanning.at&lt;uchar&gt;(1,0) = Image.at&lt;uchar&gt;(y,x-1); kernel_nowscanning.at&lt;uchar&gt;(1,1) = Image.at&lt;uchar&gt;(y,x); //center-pixel kernel_nowscanning.at&lt;uchar&gt;(1,2) = Image.at&lt;uchar&gt;(y,x+1); kernel_nowscanning.at&lt;uchar&gt;(2,0) = Image.at&lt;uchar&gt;(y+1,x-1); kernel_nowscanning.at&lt;uchar&gt;(2,1) = Image.at&lt;uchar&gt;(y+1,x); kernel_nowscanning.at&lt;uchar&gt;(2,2) = Image.at&lt;uchar&gt;(y+1,x+1); //if center-pixel is black, go to &#x27;mittsu no check&#x27;, find out whether it can be change to white. int check1 = 0; int check2 = 0; int check3 = 0; if(kernel_nowscanning.at&lt;uchar&gt;(1,1) == 0)&#123; check1 = CheckEdge(kernel_nowscanning); check2 = CheckConnectivity(kernel_nowscanning); check3 = CheckEndPoint(kernel_nowscanning); //change center-pixel from B to W (in original-image) if(check1 == 1 &amp;&amp; check2 == 1 &amp;&amp; check3 == 1)&#123; //kernel_nowscanning.at&lt;uchar&gt;(1,1) = 255; Image.at&lt;uchar&gt;(y,x) = 255; &#125; &#125; &#125; &#125; string file_dic = &quot;result/process_time&quot; + to_string(iter_time) + &quot;.png&quot;; imwrite(file_dic, Image); cout &lt;&lt; &quot;Image saved to &quot; &lt;&lt; file_dic &lt;&lt; endl; return Image;&#125; SequentialThinning()接口方法可以被用户(主函数)调用，对给定的图样进行N次骨干提取，将结果保存在result路径下。 12345678910void LWCThinning::SequentialThinning(Mat&amp; Image, int num_iterations)&#123; Mat processedImage = Image.clone(); for(int i=0; i &lt; num_iterations; i++)&#123; processedImage = solve(processedImage, i); cout &lt;&lt; &quot;||||&quot; &lt;&lt; i &lt;&lt; &quot;||||&quot;; &#125; imshow(&quot;Final Processed Image&quot;, processedImage); waitKey(0); cout &lt;&lt; &quot;Processing Completed.&quot; &lt;&lt; endl;&#125; 初步测试结果ABCD英文字符 字母A： 字母C： 字母E： 复杂的彩色图样首先将彩色图片读取为灰度图，然后进行二值化处理，最后再调用SequentialThinning。 12345678910int main()&#123; //Complex image Mat image_ena = imread(&quot;source/ENANA.png&quot;, IMREAD_GRAYSCALE); Mat binary_image; double threshold_value = 128; threshold(image_ena, binary_image, threshold_value, 255, THRESH_BINARY); LWCThinning handle; handle.SequentialThinning(binary_image,5);&#125; 测试原图与处理后图像如下： 原图： 转化为二值化图像： 我们把处理后的图像放大观察，可以看到骨干提取的一些细节。比如衣服的领带和眼睛等等： 问题：对于复杂图像，处理后的图像中存在很多垂直水平面的直线（噪声），如何去除？优化一：“Zhang-Suen算法”问题就出在我们对原始图像的处理顺序上。我们总是从上往下、从左往右地进行逐行扫描，这种顺序性可能导致水平或垂直方向的像素被优先移除或保留，从而产生水平或垂直的直线。这直接导致了很多倾斜的骨干被强制地转化为了垂直的直线。 从上方测试图“字母A”可以看出这种状况，并且在彩色测试图中也很明显能发现许多垂直直线。 Zhang-Suen算法与先前自己实现的算法相比，其实就是check部分的逻辑不同。Zhang-Suen算法会先后进行两次遍历，一次是UpDown一次是LeftRight。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//zhangsuen -----------------------------------------------------int LWCThinning::UpDownCheck(Mat&amp; image3x3)&#123; /* ---- */ if((B &gt;= 2 &amp;&amp; B &lt;= 6) &amp;&amp; T == 1 &amp;&amp; ((P2*P4*P6 == 0) || (P4*P6*P8 == 0))) return 1; else return 0;&#125;int LWCThinning::LeftRightCheck(Mat&amp; image3x3)&#123; /* ---- */ if((B &gt;= 2 &amp;&amp; B &lt;= 6) &amp;&amp; T == 1 &amp;&amp; ((P2*P4*P8 == 0) || (P2*P6*P8 == 0))) return 1; else return 0;&#125;Mat LWCThinning::zhangsuen_solve(Mat&amp; Image, int iter_time)&#123; int img_width = Image.size().width; int img_height = Image.size().height; for(int y = 1; y &lt; img_height-1; y++)&#123; for(int x = 1; x &lt; img_width-1; x++)&#123; Mat kernel_nowscanning = Mat::zeros(3,3,CV_8UC1); kernel_nowscanning.at&lt;uchar&gt;(0,0) = Image.at&lt;uchar&gt;(y-1,x-1); kernel_nowscanning.at&lt;uchar&gt;(0,1) = Image.at&lt;uchar&gt;(y-1,x); kernel_nowscanning.at&lt;uchar&gt;(0,2) = Image.at&lt;uchar&gt;(y-1,x+1); kernel_nowscanning.at&lt;uchar&gt;(1,0) = Image.at&lt;uchar&gt;(y,x-1); kernel_nowscanning.at&lt;uchar&gt;(1,1) = Image.at&lt;uchar&gt;(y,x); //center-pixel kernel_nowscanning.at&lt;uchar&gt;(1,2) = Image.at&lt;uchar&gt;(y,x+1); kernel_nowscanning.at&lt;uchar&gt;(2,0) = Image.at&lt;uchar&gt;(y+1,x-1); kernel_nowscanning.at&lt;uchar&gt;(2,1) = Image.at&lt;uchar&gt;(y+1,x); kernel_nowscanning.at&lt;uchar&gt;(2,2) = Image.at&lt;uchar&gt;(y+1,x+1); if(kernel_nowscanning.at&lt;uchar&gt;(1,1) == 0)&#123; int firstcheck = UpDownCheck(kernel_nowscanning); if(firstcheck == 1)&#123; Image.at&lt;uchar&gt;(y,x) = 255; &#125; &#125; &#125; &#125; for(int y = 1; y &lt; img_height-1; y++)&#123; for(int x = 1; x &lt; img_width-1; x++)&#123; Mat kernel_nowscanning = Mat::zeros(3,3,CV_8UC1); kernel_nowscanning.at&lt;uchar&gt;(0,0) = Image.at&lt;uchar&gt;(y-1,x-1); kernel_nowscanning.at&lt;uchar&gt;(0,1) = Image.at&lt;uchar&gt;(y-1,x); kernel_nowscanning.at&lt;uchar&gt;(0,2) = Image.at&lt;uchar&gt;(y-1,x+1); kernel_nowscanning.at&lt;uchar&gt;(1,0) = Image.at&lt;uchar&gt;(y,x-1); kernel_nowscanning.at&lt;uchar&gt;(1,1) = Image.at&lt;uchar&gt;(y,x); //center-pixel kernel_nowscanning.at&lt;uchar&gt;(1,2) = Image.at&lt;uchar&gt;(y,x+1); kernel_nowscanning.at&lt;uchar&gt;(2,0) = Image.at&lt;uchar&gt;(y+1,x-1); kernel_nowscanning.at&lt;uchar&gt;(2,1) = Image.at&lt;uchar&gt;(y+1,x); kernel_nowscanning.at&lt;uchar&gt;(2,2) = Image.at&lt;uchar&gt;(y+1,x+1); if(kernel_nowscanning.at&lt;uchar&gt;(1,1) == 0)&#123; int secondcheck = LeftRightCheck(kernel_nowscanning); if(secondcheck == 1)&#123; Image.at&lt;uchar&gt;(y,x) = 255; &#125; &#125; &#125; &#125; string file_dic = &quot;result/process_time&quot; + to_string(iter_time+1) + &quot;.png&quot;; imwrite(file_dic, Image); cout &lt;&lt; &quot;Image saved to &quot; &lt;&lt; file_dic &lt;&lt; endl; return Image;&#125; 优化结果貌似没有解决垂直直线较多的问题… 优化二：利用“特性点提取”消除直线刚刚在做“特征点提取”的工作时，突然来了灵感：我发现这些多余的直线都是由非特征点组成的，亦或是原理特征点的。换言之，我们只要提取了骨架图的特征点，然后去除远离特征点的点即可！ 特征点提取 这是特征点提取后的图片，不同的特征点标上了不同的颜色： 孤立点 isolated point：红色。 端点 end point：绿色。 3分歧点：蓝色。图片中的阶梯状斜线属于这一类。 4分歧点：黄色。十字路口。 我们可以放大图片观察一下细节：（由于4分歧点的黄色标注看的不明显，我在边上放了一双眼睛。） 特征点提取的核心代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677int LWCThinning::Check_3BranchPoint(Mat&amp; image3x3)&#123; /* ----- */ if(B &gt;= 3 &amp;&amp; (T == 2 || T == 3))&#123; return 1; &#125; else&#123; return 0; &#125;&#125;int LWCThinning::Check_4BranchPoint(Mat&amp; image3x3)&#123; /* ----- */ if(T == 4 || (image3x3.at&lt;uchar&gt;(0,1) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(1,0) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(1,2) == 0 &amp;&amp; image3x3.at&lt;uchar&gt;(2,1) == 0))&#123; return 1; &#125; else&#123; return 0; &#125;&#125;Mat LWCThinning::FeatureExtraction(Mat&amp; Image)&#123; Mat rgbImage; //After PixelAnalyzing cvtColor(Image, rgbImage, COLOR_GRAY2BGR); int img_width = Image.size().width; int img_height = Image.size().height; for(int y = 1; y &lt; img_height-1; y++)&#123; for(int x = 1; x &lt; img_width-1; x++)&#123; Mat kernel_nowscanning = Mat::zeros(3,3,CV_8UC1); kernel_nowscanning.at&lt;uchar&gt;(0,0) = Image.at&lt;uchar&gt;(y-1,x-1); kernel_nowscanning.at&lt;uchar&gt;(0,1) = Image.at&lt;uchar&gt;(y-1,x); kernel_nowscanning.at&lt;uchar&gt;(0,2) = Image.at&lt;uchar&gt;(y-1,x+1); kernel_nowscanning.at&lt;uchar&gt;(1,0) = Image.at&lt;uchar&gt;(y,x-1); kernel_nowscanning.at&lt;uchar&gt;(1,1) = Image.at&lt;uchar&gt;(y,x); //center-pixel kernel_nowscanning.at&lt;uchar&gt;(1,2) = Image.at&lt;uchar&gt;(y,x+1); kernel_nowscanning.at&lt;uchar&gt;(2,0) = Image.at&lt;uchar&gt;(y+1,x-1); kernel_nowscanning.at&lt;uchar&gt;(2,1) = Image.at&lt;uchar&gt;(y+1,x); kernel_nowscanning.at&lt;uchar&gt;(2,2) = Image.at&lt;uchar&gt;(y+1,x+1); int check_iso = 0; //isolated point int check_endpoint = 0; //end point int check_3branchpoint = 0; //3branchpoint int check_4branchpoint = 0; //4branchpoint if(kernel_nowscanning.at&lt;uchar&gt;(1,1) == 0)&#123; check_iso = CheckEdge(kernel_nowscanning); check_endpoint = CheckEndPoint(kernel_nowscanning); check_3branchpoint = Check_3BranchPoint(kernel_nowscanning); check_4branchpoint = Check_4BranchPoint(kernel_nowscanning); if(check_iso == 0)&#123; rgbImage.at&lt;Vec3b&gt;(y, x)[0] = 0; rgbImage.at&lt;Vec3b&gt;(y, x)[1] = 0; rgbImage.at&lt;Vec3b&gt;(y, x)[2] = 255; //Red &#125; if(check_endpoint == 0)&#123; rgbImage.at&lt;Vec3b&gt;(y, x)[0] = 0; rgbImage.at&lt;Vec3b&gt;(y, x)[1] = 255; //Green rgbImage.at&lt;Vec3b&gt;(y, x)[2] = 0; &#125; if(check_3branchpoint == 1)&#123; rgbImage.at&lt;Vec3b&gt;(y, x)[0] = 255; //Blue rgbImage.at&lt;Vec3b&gt;(y, x)[1] = 0; rgbImage.at&lt;Vec3b&gt;(y, x)[2] = 0; &#125; if(check_4branchpoint == 1)&#123; rgbImage.at&lt;Vec3b&gt;(y, x)[0] = 0; rgbImage.at&lt;Vec3b&gt;(y, x)[1] = 255; rgbImage.at&lt;Vec3b&gt;(y, x)[2] = 255; &#125; &#125; &#125; &#125; return rgbImage;&#125; 利用“特性点提取”消除直线仍然使用3x3的扫描核kernel（中心像素为注目像素），如果kernel内不存在彩色像素，即不存在特征点，那么就删去这个中心像素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Mat LWCThinning::removeLinesUseFeatureExtraction(Mat&amp; Image)&#123; int img_width = Image.size().width; int img_height = Image.size().height; for(int y = 1; y &lt; img_height-1; y++)&#123; for(int x = 1; x &lt; img_width-1; x++)&#123; Mat kernel_nowscanning = Mat::zeros(3,3,CV_8UC3); kernel_nowscanning.at&lt;Vec3b&gt;(0,0) = Image.at&lt;Vec3b&gt;(y-1,x-1); kernel_nowscanning.at&lt;Vec3b&gt;(0,1) = Image.at&lt;Vec3b&gt;(y-1,x); kernel_nowscanning.at&lt;Vec3b&gt;(0,2) = Image.at&lt;Vec3b&gt;(y-1,x+1); kernel_nowscanning.at&lt;Vec3b&gt;(1,0) = Image.at&lt;Vec3b&gt;(y,x-1); kernel_nowscanning.at&lt;Vec3b&gt;(1,1) = Image.at&lt;Vec3b&gt;(y,x); //center-pixel kernel_nowscanning.at&lt;Vec3b&gt;(1,2) = Image.at&lt;Vec3b&gt;(y,x+1); kernel_nowscanning.at&lt;Vec3b&gt;(2,0) = Image.at&lt;Vec3b&gt;(y+1,x-1); kernel_nowscanning.at&lt;Vec3b&gt;(2,1) = Image.at&lt;Vec3b&gt;(y+1,x); kernel_nowscanning.at&lt;Vec3b&gt;(2,2) = Image.at&lt;Vec3b&gt;(y+1,x+1); if(kernel_nowscanning.at&lt;Vec3b&gt;(1,1)[0] == 0 &amp;&amp; kernel_nowscanning.at&lt;Vec3b&gt;(1,1)[1] == 0 &amp;&amp; kernel_nowscanning.at&lt;Vec3b&gt;(1,1)[2] == 0)&#123; int is_coloured = ColorPixelDetect(kernel_nowscanning); if(!is_coloured)&#123; //remove(change to W) Image.at&lt;Vec3b&gt;(y,x)[0] = 255; Image.at&lt;Vec3b&gt;(y,x)[1] = 255; Image.at&lt;Vec3b&gt;(y,x)[2] = 255; &#125; &#125; &#125; &#125; return Image;&#125;int LWCThinning::ColorPixelDetect(Mat&amp; image3x3)&#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; Vec3b pixel = image3x3.at&lt;Vec3b&gt;(i, j); int B = pixel[0]; int G = pixel[1]; int R = pixel[2]; //have colour if (!((B == 255 &amp;&amp; G == 255 &amp;&amp; R == 255) || (B == 0 &amp;&amp; G == 0 &amp;&amp; R == 0))) &#123; return 1; &#125; &#125; &#125; return 0;&#125; 优化结果动漫人物图片：ShinonomeEnana 原图： 初步骨架提取： 特征点提取： 利用特征点去直线： 环境景色图片：ひびきの南 原图： 初步骨架提取： 特征点提取： 利用特征点去直线： 包含大量文字的图片：日本年号对照表 原图： 初步骨架提取： 特征点提取： 我们发现对文字进行处理后效果已经很好了，因此无需再继续优化。","categories":[{"name":"LAB EXERCISE","slug":"LAB-EXERCISE","permalink":"https://shinononome-enana.github.io/categories/LAB-EXERCISE/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://shinononome-enana.github.io/tags/CPP/"},{"name":"Tough-Transform","slug":"Tough-Transform","permalink":"https://shinononome-enana.github.io/tags/Tough-Transform/"}]},{"title":"如何区分使用「ないで」和「なくて」","slug":"nihongo-nakutenaide","date":"2024-11-15T09:07:56.000Z","updated":"2025-03-26T13:25:35.354Z","comments":true,"path":"2024/11/15/nihongo-nakutenaide/","permalink":"https://shinononome-enana.github.io/2024/11/15/nihongo-nakutenaide/","excerpt":"","text":"问题思考当我们学习日语接触到“接续”这个概念时，我们会用到各种词性的テ形，比如： 形容词接续形容词(即…又…)： 寂しくて辛い &#x2F; きれいで明るい 动词接续动词（先做…后做…）： 学校から帰って(から)勉強します。 名词接续名词(是…又是…)： 彼は会社員で、３人の子供の父親です。 但不难发现，上述例子中均是正向表达。如果使用“否定”那又将如何表达呢？如果与此同时使用原形，对于初学者来说非常难以在第一时间想到如何表达。前几天，我在和日本人日常交流时，突然遇到了以下几个问题： 动词否定接续时到底用「ないで」还是「なくて」？ 一类形容词“过去否定”「なかった」如何接续？ 经过我的学习和查阅，现在我可以来解释我提出的这些疑问。 否定「ない」接续时到底变「ないで」还是「なくて」？其实早在N5时期，我们就接触到了很多使用到「ないで」和「なくて」的文法，诸如： ～しないでください！ 请不要做….。 ～しなくてもいいです。 不做….也可以。 只不过我们当时没有多去考虑这两个句型中为什么前者用「ないで」后者用「なくて」。 「ないで」只能动词接，而「なくて」动词名词形容词均可在表达否定「ない」的接续(テ形)时，日语中存在「ないで」和「なくて」两种表达。 对于形容词和名词而言，一定有「ない」-&gt; 「なくて」。如： 暑くない -&gt; 暑くなくて： この部屋が暑くなくてきれいだと思う。有名じゃない -&gt; 有名じゃなくて： この町が有名じゃなくて、景色も他の町に比べ物にならない。学生じゃない -&gt; 学生じゃなくて： 彼は学生じゃなくて会社員じゃない。 对于动词而言，「ない」-&gt; 「なくて」&#x2F;「ないで」均可。如： 食べない -&gt; 食べなくて： 朝ご飯を食べなくて学校へ行きます。食べない -&gt; 食べないで： 朝ご飯を食べないで学校へ行きます。 显然，上面两个句子表达的含义是不一样的，光光是读出来给人的感觉就不一样了。因此，动词「ない」-&gt; 「なくて」或者「ない」-&gt; 「ないで」的含义不同。 动词「ないで」&#x2F;「なくて」接续动词的区别：前者状态，后者因果。 「ないで」 从语感上或者说从文法上，助词「で」给人一种“基于…状态”，“在…状态下”的感觉。比如我在超市里付钱时，我会说「現金で」表示我要用现金支付，这里的「で」是手段；又比如每次打舞萌都做公交车出勤，我会说「バスで行く」，这里的「で」是交通工具。 我们迁移到「ないで」上：我们可以认为「ないで」其实就是简单的「ない」加了一个助词「で」，表示“在没有(做)….的情况下,….”，“在…状态下…”。我们还可以顺水推舟地发现，「ないで」严格意义上并不是「ない」的テ形，表义的功劳都在助词「で」上。 在网络上看到一个评论感觉说的相当有道理：で就是 with, ないで就是without。 意思和我上面长篇大论表述的如出一辙。 朝ご飯を食べないで学校へ行きます。 在没有吃早饭的情况下就直接去了学校。 这个句子里的「朝ご飯を食べないで」就是表达了：其后「学校へ行きます」动作发生的条件&#x2F;状态是「朝ご飯を食べないで」。下面有更多的例句，可以自行体会语感。 シートベルトをつけないで運転することが危ないです！ 在不系安全带的状态下开车是危险的 教科書を見ないで答えてみます。 在不看课本的状态下试着回答一下。 毎日ゲームばっかり勉強しないで、試験に合格するわけがないだろう！ 每天只顾玩游戏不学习，不可能通过考试吧！ 「なくて」 前面说「ないで」严格意义上并不是「ない」的テ形，那么「なくて」就是严格意义上「ない」的テ形了。当前后有因果关系时，会使用到「なくて」。比如下面这个例句，出自番剧《间谍过家家》里可爱的阿尼亚： アニヤ、母いなくて寂しい～ 阿尼亚没有妈妈好寂寞~ 这里阿尼亚感到寂寞是因为没有妈妈，所以这里有因果关系。如果用「ないで」就变成阿尼亚说自己在没有妈妈的状态下寂寞了，让人感觉怪怪的。还有一些例句： お金がなくて旅行できない。 (因为)没钱(所以)没法出去旅游。 「ないで」&#x3D;「ずに」在N3的语法中我们还学过，动词否定还有一种形式是以「ず」结尾，即「ないで」&#x3D;「ずに」。这里的「ずに」明显是与其后接续的另外一个动词有关联性，如： 遠慮しないでいきましょう！ ＝ 遠慮せずに行きましょう！ 遠慮しなくていきましょう！ × 不用担心，就这样上吧！（碧蓝幻想relink中夏洛特的副本出发语音。） 一类形容词“过去否定”「なかった」如何接续？以「面白い」为例：「面白い」接续变テ形「面白くて」，其一般否定形式「面白くない」接续变テ形「面白くなくて」。那么问题来了，其过去否定形式「面白くなかった」接续怎么变テ形呢？我想破了脑袋也没想出来「なかった」怎么变テ形，因为「なかった」准确来说已经是一个タ形了。 其实，如果真想在「なかった」后面接续，直接分成两个句子并用「が」&#x2F;「けれど」等助词连接即可，不用テ形。 比如： この映画は面白くなかったけど、映像は綺麗だった。 (昨天看的)这部电影不有趣，但画面很漂亮。 昨日のプレゼンは緊張感がなく、あまり印象的ではなかったが、今日のプレゼンはとても説得力があって素晴らしかった。 昨天的演讲没有紧张感，也不是很有印象深刻，但今天的演讲非常有说服力，非常出色。","categories":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}]},{"title":"关于「させていただきます」的几点理解","slug":"nihongo-itadaku","date":"2024-11-14T14:59:06.000Z","updated":"2024-11-15T08:52:36.759Z","comments":true,"path":"2024/11/14/nihongo-itadaku/","permalink":"https://shinononome-enana.github.io/2024/11/14/nihongo-itadaku/","excerpt":"","text":"问题引发今天上日语中级会话课的时候，看到了几个用到了敬语「いただく」的句子。 （お店の張り紙）本日は定休日につき、休ませていただきます。 ー ぜひ鈴木さんの下でプロジェクトを担当させていただきたいと思っておいます。 从一开始学习日语我就比较头疼敬语，尤其是「いただく」这种与其他语法亦有繁多组合的敬语文法（比如可以组合成「させていただいてもいいですか」、「いただきたい」等等），这让我有一丝的畏惧，因此我一直没有理解这一部分。今天正好有兴致研究这一部分，趁此机会或许可以透析一下这个文法。 「いただきます」是「もらう」的自谦语在N4学习“授受关系”时，书上或者老师肯定会提到三个“授受关系”动词的敬语形态。 あげる：我给别人。 —&gt; 差し上げます（さしあげます） もらう：我&#x2F;别人收到。 —&gt; 頂きます（いただきます） くれる：我收到。(私にくれる) —&gt; くださいます 虽然是简单的N4语法，也有必要重新说明一下： 「いただきます」是「もらう」的自谦语，表示主语是动作的接收方。 比如：「彼に手伝ってもらう」表示接收到了他的帮助；「母にパソコンを買ってもらう」表示妈妈帮我买了电脑(我接受到了妈妈买电脑的动作)。 当然，对于二次元来说「いただきます」可谓是再熟悉不过了，因为日本人吃饭前都会说一句：“いただきます！”，字幕通常把他翻译成：“我开动了！”。这是因为「いただきます」还是「食べる」和「飲む」的自谦形式。 我自己说我自己要吃&#x2F;喝了，那按道理就要用谦让语了。至于为什么要在开饭前对着家人或者朋友说敬语，这只能解释为日本人几百年来养成的语言习惯了。不过，「させていただきます」中的「いただきます」是「もらう」的自谦语，并不是「食べる」或者「飲む」的自谦语，因此本博客主要还是讨论前者。 「させてもらう」-&gt;「させていただきます」：请允许我做 「させていただきます」表达一种“征求对方同意”的语义，可以翻译成“请允许我(做)……”，是一个自谦语表达。他的原形是「させてもらう」。 过去式「させていただきました」并不是为了表示时间上的过去，而是出于礼貌，表示自己已经领受或得到了对方的许可，从而更加尊重对方的心意。日语中，尤其是敬语表达时，过去式并不一定是指时间上的过去，而更多是表达一种「完了」的状态，以传达谦逊和礼貌。 如果从文法的角度思考，「させる」是使役形（让…做），其テ形后续接动词 「いただく」。从文法上的理解，「させていただきます」的意思是”让我获得…”，或者说”让我得到做…（的允许）”。如果使用过去式「させていただきした」，难道要理解成过去已经允许我做过某些事？这样理解起来还是有些别扭。 其实我们没有必要一味追求语法的思考，我认为首先我们需要记住他的意思并记忆一些例句，积累语感。我们从「させてもらう」开始，转变到「させていただきます」。 紹介させてもらいます。 電話させてもらいました。 食べさせてもらった。 紹介させていただきます。 電話させていただきました。 食べさせていただきました。 请允许我介绍一下。 承蒙您的允许，我给您打电话了。 —&gt; 我给您打电话，打扰您了。 承蒙您的允许，我吃了。 —&gt; 多谢您的款待。 理解了上面几个例句，这时候我们再看第一节中的第一个句子，就非常清晰明了了。 （お店の張り紙）本日は定休日につき、休ませていただきます。（商店门口的贴纸）今天是休息日，请允许我们今天停业。 诸如「させていただいてもいいですか」的引申下面介绍几组基于「させていただきます」的几个引申文法，理解起来也并不困难。但这里肯定不可能总结所有的引申文法，也没有这个必要，只需要理解常见的即可，积累预感。 第一组：+いいですか- させてもらってもいいですか- させていただいてもいいですか- させていただいてもよろしいでしょうか 上述三个文法在「させていただきます」的基础上接续了「てもいいですか」。增加「てもいいですか」本质上是表达更加礼貌的一种请求，意思仍然是“请允许我…”，无需过多揣测其文法逻辑。另外，上述三个文法礼貌程度逐渐增加，这是因为「もらう」变「いただく」、「いいですか」变「よろしいでしょうか」都是更加尊敬的表达。 第二组：-たい- させていただきたい 由于文法主体仍然是「させていただきます」，因此「させていただきたい」表达的仍然是一种请求，只不过最后的「たい」表达了 “我想要做某事”的愿望。我们甚至可以更加简单地认为「させていただきたい」就是「～したい」&#x2F;「～することがほしいです」的礼貌自谦形式。 我们回到问题引发中的句子，发现已经可以理解了。在这里，「担当させていただきたい」表达了说话人对担任项目负责人的强烈愿望，同时使用了非常礼貌和谦逊的语气。通过使用「させていただく」，说话人显得既尊重对方，也表达了对机会的渴望。整体上，这种表达方式在正式场合或职场中非常合适，特别是向上司或领导表达希望得到某项任务或责任的请求时。 ー ぜひ鈴木さんの下でプロジェクトを担当させていただきたいと思っておいます。 —— 我非常希望能够在铃木先生的领导下负责这个项目。 第三组：可能形- させていただけませんか- させていただけないでょうか 文法上，「いただけます」是「いただく」的可能形。但 「させていただけませんか」其实也表示“能不能让我做……”的请求，可以视为「させていただきます」的另一种说法。 「させていただけないでしょうか」是「させていただけませんか」的稍微更正式或更委婉的说法，意思是几乎相同。语感上「ないでしょうか」带有更强的请求语气，通常用于非常正式或需要特别委婉表达的场合。 很好的视频","categories":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}]},{"title":"用原生opencv代码实现霍夫变换(Tough-Transform)","slug":"opencv","date":"2024-11-10T13:08:01.000Z","updated":"2025-01-03T13:06:36.530Z","comments":true,"path":"2024/11/10/opencv/","permalink":"https://shinononome-enana.github.io/2024/11/10/opencv/","excerpt":"","text":"基本要求 Hough transform is a very classic and useful method for the detection of curves or lines. It uses the transformation of two coordinate spaces (the image space and the Hough space) to map curves or straight lines to points in another coordinate space to vote and form peaks, thus transforming the problem of detecting arbitrary shapes into a statistical peak problem.In this task, you can draw some lines or circles by yourself and use Hough Transform to detect the figure you drew (you can try for lines firstly and then for circles). MUST implement it yourself! 代码框架12345678910class ToughTransform&#123; public: void LineDetection(Mat&amp; Image); void CircleDetection(Mat&amp; Image); private: void ShowParameterSpace(vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale); void DrawLineDetectedImage(Mat&amp; Image, vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, int row_max, int theta_max , int second_filter_threshold); void ShowParameterSpace_Circle(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale); void DrawCircleDetectedImage(Mat&amp; Image,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, int max_a, int max_b, int max_r, int second_filter_threshold);&#125;; 直线检测 void LineDetection(Mat&amp; Image): 算法主流程。包括将图像转化到二维参数空间(row,theta),对参数空间矩阵进行初次阈值过滤,以及调用ShowParameterSpace和DrawLineDetectedImage方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* LineDetection: ShowParameterSpace + DrawLineDetectedImage*/void ToughTransform::LineDetection(Mat&amp; Image)&#123; int img_width = Image.size().width; int img_height = Image.size().height; //ParameterSpace[row][theta] double row_max = sqrt(img_width * img_width + img_height * img_height); int theta_max = 180; //theta: step_length = 1 vector&lt;vector&lt;int&gt;&gt; PatameterSpace(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); cout &lt;&lt; &quot;ImageSize:&quot; &lt;&lt; img_height &lt;&lt; &quot;*&quot; &lt;&lt; img_width &lt;&lt; endl; cout &lt;&lt; &quot;PatameterSpace:&quot; &lt;&lt; 2*row_max &lt;&lt; &quot;*&quot; &lt;&lt; theta_max &lt;&lt; &quot; --&gt; &quot; &lt;&lt; 2 * static_cast&lt;int&gt;(ceil(row_max)) &lt;&lt; &quot;*&quot; &lt;&lt; theta_max &lt;&lt; endl; for (int y = 0; y &lt; img_height; y++)&#123; for (int x = 0; x &lt; img_width; x++)&#123; int B = Image.at&lt;Vec3b&gt;(y,x)[0]; int G = Image.at&lt;Vec3b&gt;(y,x)[1]; int R = Image.at&lt;Vec3b&gt;(y,x)[2]; if(B == 0 &amp;&amp; G == 0 &amp;&amp; R == 0)&#123; //Edge is black-pixel //!!!look through theta, calc row than write into parameter-space!!! //遍历theta，计算row，存入参数空间 for(int theta = 0; theta &lt;= theta_max; theta++)&#123; double theta_rad = theta * PI / 180.0; double row = x * cos(theta_rad) + y * sin(theta_rad); //row可能是负的,row_max作为偏移量. 将偏移量row_max加到row上，转为非负索引 //cout &lt;&lt; &quot;row = &quot; &lt;&lt; row &lt;&lt; &quot; ---&gt; &quot; &lt;&lt; row + row_max &lt;&lt; &quot; ---&gt; &quot; &lt;&lt; ceil(row) + ceil(row_max) &lt;&lt; endl; PatameterSpace[static_cast&lt;int&gt;(ceil(row) + ceil(row_max))][theta]++; &#125; &#125; &#125; &#125; int threshold = 10; vector&lt;vector&lt;int&gt;&gt; PS_AfterFilter(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); //threshold-filter for (int i = 0; i &lt; PatameterSpace.size(); i++)&#123; for (int j = 0; j &lt; PatameterSpace[0].size(); j++)&#123; if(PatameterSpace[i][j] &gt;= threshold) PS_AfterFilter[i][j] = PatameterSpace[i][j]; else PS_AfterFilter[i][j] = 0; &#125; &#125; ShowParameterSpace(PS_AfterFilter,&quot;source/line-result/EnhancedHoughSpaceImage-FirstFilter.png&quot;); int second_filter_threshold = 500; DrawLineDetectedImage(Image,PS_AfterFilter,static_cast&lt;int&gt;(ceil(row_max)),theta_max,second_filter_threshold);&#125; ShowParameterSpace(vector&lt;vector&gt;&amp; PS_AfterFilter, string file_name, int thetaScale)： 在LineDetection和DrawLineDetectedImage中被调用，可以描绘出二维参数空间PS_AfterFilter(row,theta)的点分布。其中file_name是图片保存地址；thetaScale将theta轴拉伸，以达到更好的可视化效果。 1234567891011121314151617181920212223242526272829/* ShowParameterSpace: 描绘(row,theta)参数空间的图像。此时的参数矩阵PS_AfterFilter只经历了初步的阈值筛选。*/void ToughTransform::ShowParameterSpace(vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale = 15)&#123; int rows = PS_AfterFilter.size(); int cols = PS_AfterFilter[0].size(); Mat houghSpaceImage(rows, cols, CV_8UC1, Scalar(0)); int maxVal = 0; for (const auto&amp; row : PS_AfterFilter) &#123; maxVal = max(maxVal, *max_element(row.begin(), row.end())); &#125; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; houghSpaceImage.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(255.0 * PS_AfterFilter[i][j] / maxVal); &#125; &#125; Mat enlargedHoughSpace; resize(houghSpaceImage, enlargedHoughSpace, Size(cols * thetaScale, rows), 0, 0, INTER_LINEAR); Mat colorHoughSpace; applyColorMap(enlargedHoughSpace, colorHoughSpace, COLORMAP_JET); namedWindow(&quot;Enhanced Hough Space&quot;, WINDOW_NORMAL); imshow(&quot;Enhanced Hough Space&quot;, colorHoughSpace); imwrite(file_name, colorHoughSpace); waitKey(0);&#125; DrawLineDetectedImage(Mat&amp; Image, vector&lt;vector&gt;&amp; PS_AfterFilter, int row_max, int theta_max , int second_filter_threshold): 将二维参数空间矩阵PS_AfterFilter进行更深层次的阈值筛选(阈值更大，筛选剩下的点更少)，然后反变换到”x,y直角坐标系”，描绘出检测出的直线。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* DrawDetectedImage: 二次过滤参数空间(row,theta)矩阵，然后在原图image上描绘出直线。*/void ToughTransform::DrawLineDetectedImage(Mat&amp; Image, vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, int row_max, int theta_max = 180, int second_filter_threshold = 100)&#123; //threshold-filter-second vector&lt;vector&lt;int&gt;&gt; PS_FinalFilter(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); for (int i = 0; i &lt; PS_AfterFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_AfterFilter[0].size(); j++)&#123; if(PS_AfterFilter[i][j] &gt;= second_filter_threshold) PS_FinalFilter[i][j] = PS_AfterFilter[i][j]; else PS_FinalFilter[i][j] = 0; &#125; &#125; ShowParameterSpace(PS_FinalFilter,&quot;source/line-result/EnhancedHoughSpaceImage-FinalFilter.png&quot;); int rows = PS_FinalFilter.size(); int cols = PS_FinalFilter[0].size(); for (int row = 0; row &lt; rows; row++) &#123; for (int theta = 0; theta &lt; cols; theta++) &#123; if (PS_FinalFilter[row][theta] != 0) &#123; double this_theta_rad = theta * PI / 180.0; double this_row = row - row_max; Point pt1, pt2; double a = cos(this_theta_rad); double b = sin(this_theta_rad); double x0 = a * this_row; double y0 = b * this_row; pt1.x = cvRound(x0 + 1000 * (-b)); pt1.y = cvRound(y0 + 1000 * (a)); pt2.x = cvRound(x0 - 1000 * (-b)); pt2.y = cvRound(y0 - 1000 * (a)); line(Image, pt1, pt2, Scalar(0, 0, 255), 2, LINE_AA); &#125; &#125; &#125; namedWindow(&quot;Detected Lines&quot;, WINDOW_NORMAL); imshow(&quot;Detected Lines&quot;, Image); imwrite(&quot;source/line-result/DetectedLinesImage.png&quot;, Image); waitKey(0);&#125; 调试方法： 调整阈值second_filter_threshold直到合适。如果阈值太低，描绘的直线就会过多，图上一片混乱；如果阈值太高，则不会有检测结果。 测试输入测试图片，主函数调用LineDetection(Mat&amp; Image)即可。 测试图像如下。 霍夫变换并初步阈值过滤(threshold&#x3D;10)后，检测出的直线二维参数空间(row,theta)图像。 二次深度阈值过滤(threshold&#x3D;500)后，检测出的直线二维参数空间(row,theta)图像。 反变换到直角坐标，原图上描绘出检测到的直线。 圆检测 CircleDetection(Mat&amp; Image): 算法主流程。包括将图像转化到三维参数空间(a,b,r)，其中圆心坐标为(a,b)，圆的半径是r。对参数空间矩阵进行初次阈值过滤,以及调用ShowParameterSpace_Circle和DrawCircleDetectedImage方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* CircleDetection: ShowParameterSpace_Circle + DrawCircleDetectedImage*/void ToughTransform::CircleDetection(Mat&amp; Image)&#123; //在霍夫变换中，我们通过三个参数来描述一个圆：圆心的坐标(a,b)和半径r. int img_width = Image.size().width; int img_height = Image.size().height; //ParameterSpace[b][a][r] b---&gt;height---&gt;y | a---&gt;width---&gt;x int max_a = img_width; int max_b = img_height; int max_r = static_cast&lt;int&gt;(0.5* min(max_a,max_b)); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; ParameterSpace(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); for (int y = 0; y &lt; img_height; y++)&#123; for (int x = 0; x &lt; img_width; x++)&#123; int B = Image.at&lt;Vec3b&gt;(y,x)[0]; int G = Image.at&lt;Vec3b&gt;(y,x)[1]; int R = Image.at&lt;Vec3b&gt;(y,x)[2]; if(B == 0 &amp;&amp; G == 0 &amp;&amp; R == 0)&#123; //Edge is black-pixel //遍历r，计算row，存入参数空间: min_r = 20 --&gt; max_r for(int r = 20; r &lt;= max_r; r++)&#123; //遍历每个r情况下的theta(一周)，计算a&amp;b，存入参数空间 for(int theta = 0; theta &lt; 360; theta++)&#123; double theta_rad = theta * PI / 180.0; int a = static_cast&lt;int&gt;(x - r * cos(theta_rad)); int b = static_cast&lt;int&gt;(y - r * sin(theta_rad)); if(a &gt;= 0 &amp;&amp; a &lt; max_a &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; max_b)&#123; ParameterSpace[b][a][r]++; &#125; &#125; &#125; &#125; &#125; &#125; //threshold-filter int threshold = 10; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; PS_AfterFilter(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); //threshold-filter for (int i = 0; i &lt; ParameterSpace.size(); i++)&#123; for (int j = 0; j &lt; ParameterSpace[0].size(); j++)&#123; for (int k = 0; k &lt; ParameterSpace[0][0].size(); k++)&#123; if(ParameterSpace[i][j][k] &gt;= threshold) PS_AfterFilter[i][j][k] = ParameterSpace[i][j][k]; else PS_AfterFilter[i][j][k] = 0; &#125; &#125; &#125; ShowParameterSpace_Circle(PS_AfterFilter,&quot;source/circle-result/EnhancedHoughSpaceImage-FirstFilter.png&quot;); const int second_filter_threshold = 300; DrawCircleDetectedImage(Image,PS_AfterFilter,max_a,max_b,max_r,second_filter_threshold);&#125; ShowParameterSpace_Circle(vector&lt;vector&lt;vector&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale)： 传入三维参数矩阵PS_AfterFilter，描绘图像。其中file_name是图片保存地址；thetaScale将theta轴拉伸，以达到更好的可视化效果。 12345678910111213141516171819202122232425262728void ToughTransform::ShowParameterSpace_Circle(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale = 1)&#123; int height = PS_AfterFilter.size(); //row的范围 int width = PS_AfterFilter[0].size(); // theta的范围 int num_r = PS_AfterFilter[0][0].size(); // 半径r的数量 Mat parameter_space_image(height, width, CV_8UC1, cv::Scalar(0)); for (int b = 0; b &lt; height; b++) &#123; for (int a = 0; a &lt; width; a++) &#123; for (int r = 0; r &lt; num_r; r++) &#123; int accumulator_value = PS_AfterFilter[b][a][r]; // 将累积值映射到0-255的范围（可以根据实际情况调整比例） int intensity = static_cast&lt;int&gt;(255.0 * accumulator_value / 255.0); parameter_space_image.at&lt;uchar&gt;(b, a) = intensity; &#125; &#125; &#125; Mat enlargedHoughSpace; resize(parameter_space_image, enlargedHoughSpace, Size(width * thetaScale, height), 0, 0, INTER_LINEAR); Mat colorHoughSpace; applyColorMap(enlargedHoughSpace, colorHoughSpace, COLORMAP_JET); namedWindow(&quot;Detected Circles&quot;, WINDOW_NORMAL); imshow(&quot;Detected Circles&quot;, colorHoughSpace); imwrite(file_name, colorHoughSpace); waitKey(0);&#125; DrawCircleDetectedImage(Mat&amp; Image,vector&lt;vector&lt;vector&gt;&gt;&amp; PS_AfterFilter, int max_a, int max_b, int max_r, int second_filter_threshold)： 传入三维参数空间PS_AfterFilter，利用second_filter_threshold进行二次阈值筛选后，反变换到直角坐标。由于是圆检测，只需要取出圆心(x,y)和半径r的值，然后进行描绘即可。 123456789101112131415161718192021222324252627282930313233343536void ToughTransform::DrawCircleDetectedImage(Mat&amp; Image,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, int max_a, int max_b, int max_r, int second_filter_threshold)&#123; //threshold-filter-second vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; PS_FinalFilter(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); for (int i = 0; i &lt; PS_AfterFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_AfterFilter[0].size(); j++)&#123; for (int k = 0; k &lt; PS_AfterFilter[0][0].size(); k++)&#123; if(PS_AfterFilter[i][j][k] &gt;= second_filter_threshold) PS_FinalFilter[i][j][k] = PS_AfterFilter[i][j][k]; else PS_FinalFilter[i][j][k] = 0; &#125; &#125; &#125; ShowParameterSpace_Circle(PS_FinalFilter,&quot;source/circle-result/EnhancedHoughSpaceImage-FinalFilter.png&quot;); for (int i = 0; i &lt; PS_FinalFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_FinalFilter[0].size(); j++)&#123; for (int k = 0; k &lt; PS_FinalFilter[0][0].size(); k++)&#123; //draw circle if(PS_FinalFilter[i][j][k] != 0)&#123; Point center(j, i); circle(Image, center, k, cv::Scalar(0, 0, 255), 2); //红色圆圈 &#125; &#125; &#125; &#125; namedWindow(&quot;Detected Circles&quot;, WINDOW_NORMAL); imshow(&quot;Detected Circles&quot;, Image); imwrite(&quot;source/circle-result/DrawCircleDetectedImage.png&quot;, Image); waitKey(0);&#125; 调试方法： 调整阈值second_filter_threshold直到合适。如果阈值太低，描绘的圆就会过多，图上一片混乱；如果阈值太高，则不会有检测结果。 调整参数计算时，半径的遍历上下限的r_min和r_max。r_max一般直接取图像height和width中的较小值。r_min如果取0，那么有宽度的直线也会被检测成一长串的迷你圆；r_min取得太小，可能会把交点也检测成小圆。 测试输入测试图片，主函数调用CircleDetection(Mat&amp; Image)即可。 测试图像如下。 霍夫变换并初步阈值(threshold&#x3D;10)过滤后，检测出的参数空间图像。 二次深度阈值过滤(threshold&#x3D;300)后，检测出的圆参数空间图像。 反变换到直角坐标，原图上描绘出检测到的圆。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;sstream&gt;#include &lt;ctime&gt; #include &lt;vector&gt;#include &lt;cmath&gt; #include &lt;opencv2/core.hpp&gt; // Basic OpenCV structures (cv::Mat)#include &lt;opencv2/videoio.hpp&gt; // Video write#include &lt;opencv2/imgcodecs.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/videoio.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/video.hpp&gt;using namespace std;using namespace cv;const double PI = 3.14159265358979323846;class ToughTransform&#123; public: void LineDetection(Mat&amp; Image); void CircleDetection(Mat&amp; Image); private: void ShowParameterSpace(vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale); void DrawLineDetectedImage(Mat&amp; Image, vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, int row_max, int theta_max , int second_filter_threshold); void ShowParameterSpace_Circle(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale); void DrawCircleDetectedImage(Mat&amp; Image,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, int max_a, int max_b, int max_r, int second_filter_threshold);&#125;;/* ShowParameterSpace: 描绘(row,theta)参数空间的图像。此时的参数矩阵PS_AfterFilter只经历了初步的阈值筛选。*/void ToughTransform::ShowParameterSpace(vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale = 15)&#123; int rows = PS_AfterFilter.size(); int cols = PS_AfterFilter[0].size(); Mat houghSpaceImage(rows, cols, CV_8UC1, Scalar(0)); int maxVal = 0; for (const auto&amp; row : PS_AfterFilter) &#123; maxVal = max(maxVal, *max_element(row.begin(), row.end())); &#125; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; houghSpaceImage.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(255.0 * PS_AfterFilter[i][j] / maxVal); &#125; &#125; Mat enlargedHoughSpace; resize(houghSpaceImage, enlargedHoughSpace, Size(cols * thetaScale, rows), 0, 0, INTER_LINEAR); Mat colorHoughSpace; applyColorMap(enlargedHoughSpace, colorHoughSpace, COLORMAP_JET); namedWindow(&quot;Enhanced Hough Space&quot;, WINDOW_NORMAL); imshow(&quot;Enhanced Hough Space&quot;, colorHoughSpace); imwrite(file_name, colorHoughSpace); waitKey(0);&#125;/* DrawDetectedImage: 二次过滤参数空间(row,theta)矩阵，然后在原图image上描绘出直线。*/void ToughTransform::DrawLineDetectedImage(Mat&amp; Image, vector&lt;vector&lt;int&gt;&gt;&amp; PS_AfterFilter, int row_max, int theta_max = 180, int second_filter_threshold = 100)&#123; //threshold-filter-second vector&lt;vector&lt;int&gt;&gt; PS_FinalFilter(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); for (int i = 0; i &lt; PS_AfterFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_AfterFilter[0].size(); j++)&#123; if(PS_AfterFilter[i][j] &gt;= second_filter_threshold) PS_FinalFilter[i][j] = PS_AfterFilter[i][j]; else PS_FinalFilter[i][j] = 0; &#125; &#125; ShowParameterSpace(PS_FinalFilter,&quot;source/line-result/EnhancedHoughSpaceImage-FinalFilter.png&quot;); int rows = PS_FinalFilter.size(); int cols = PS_FinalFilter[0].size(); for (int row = 0; row &lt; rows; row++) &#123; for (int theta = 0; theta &lt; cols; theta++) &#123; if (PS_FinalFilter[row][theta] != 0) &#123; double this_theta_rad = theta * PI / 180.0; double this_row = row - row_max; Point pt1, pt2; double a = cos(this_theta_rad); double b = sin(this_theta_rad); double x0 = a * this_row; double y0 = b * this_row; pt1.x = cvRound(x0 + 1000 * (-b)); pt1.y = cvRound(y0 + 1000 * (a)); pt2.x = cvRound(x0 - 1000 * (-b)); pt2.y = cvRound(y0 - 1000 * (a)); line(Image, pt1, pt2, Scalar(0, 0, 255), 2, LINE_AA); &#125; &#125; &#125; namedWindow(&quot;Detected Lines&quot;, WINDOW_NORMAL); imshow(&quot;Detected Lines&quot;, Image); imwrite(&quot;source/line-result/DetectedLinesImage.png&quot;, Image); waitKey(0);&#125;/* LineDetection: ShowParameterSpace + DrawLineDetectedImage*/void ToughTransform::LineDetection(Mat&amp; Image)&#123; int img_width = Image.size().width; int img_height = Image.size().height; //ParameterSpace[row][theta] double row_max = sqrt(img_width * img_width + img_height * img_height); int theta_max = 180; //theta: step_length = 1 vector&lt;vector&lt;int&gt;&gt; PatameterSpace(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); cout &lt;&lt; &quot;ImageSize:&quot; &lt;&lt; img_height &lt;&lt; &quot;*&quot; &lt;&lt; img_width &lt;&lt; endl; cout &lt;&lt; &quot;PatameterSpace:&quot; &lt;&lt; 2*row_max &lt;&lt; &quot;*&quot; &lt;&lt; theta_max &lt;&lt; &quot; --&gt; &quot; &lt;&lt; 2 * static_cast&lt;int&gt;(ceil(row_max)) &lt;&lt; &quot;*&quot; &lt;&lt; theta_max &lt;&lt; endl; for (int y = 0; y &lt; img_height; y++)&#123; for (int x = 0; x &lt; img_width; x++)&#123; int B = Image.at&lt;Vec3b&gt;(y,x)[0]; int G = Image.at&lt;Vec3b&gt;(y,x)[1]; int R = Image.at&lt;Vec3b&gt;(y,x)[2]; if(B == 0 &amp;&amp; G == 0 &amp;&amp; R == 0)&#123; //Edge is black-pixel //!!!look through theta, calc row than write into parameter-space!!! //遍历theta，计算row，存入参数空间 for(int theta = 0; theta &lt;= theta_max; theta++)&#123; double theta_rad = theta * PI / 180.0; double row = x * cos(theta_rad) + y * sin(theta_rad); //row可能是负的,row_max作为偏移量. 将偏移量row_max加到row上，转为非负索引 //cout &lt;&lt; &quot;row = &quot; &lt;&lt; row &lt;&lt; &quot; ---&gt; &quot; &lt;&lt; row + row_max &lt;&lt; &quot; ---&gt; &quot; &lt;&lt; ceil(row) + ceil(row_max) &lt;&lt; endl; PatameterSpace[static_cast&lt;int&gt;(ceil(row) + ceil(row_max))][theta]++; &#125; &#125; &#125; &#125; int threshold = 10; vector&lt;vector&lt;int&gt;&gt; PS_AfterFilter(2 * static_cast&lt;int&gt;(ceil(row_max)), vector&lt;int&gt;(theta_max, 0)); //threshold-filter for (int i = 0; i &lt; PatameterSpace.size(); i++)&#123; for (int j = 0; j &lt; PatameterSpace[0].size(); j++)&#123; if(PatameterSpace[i][j] &gt;= threshold) PS_AfterFilter[i][j] = PatameterSpace[i][j]; else PS_AfterFilter[i][j] = 0; &#125; &#125; ShowParameterSpace(PS_AfterFilter,&quot;source/line-result/EnhancedHoughSpaceImage-FirstFilter.png&quot;); int second_filter_threshold = 500; DrawLineDetectedImage(Image,PS_AfterFilter,static_cast&lt;int&gt;(ceil(row_max)),theta_max,second_filter_threshold);&#125;/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////void ToughTransform::ShowParameterSpace_Circle(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, string file_name, int thetaScale = 1)&#123; int height = PS_AfterFilter.size(); //row的范围 int width = PS_AfterFilter[0].size(); // theta的范围 int num_r = PS_AfterFilter[0][0].size(); // 半径r的数量 Mat parameter_space_image(height, width, CV_8UC1, cv::Scalar(0)); for (int b = 0; b &lt; height; b++) &#123; for (int a = 0; a &lt; width; a++) &#123; for (int r = 0; r &lt; num_r; r++) &#123; int accumulator_value = PS_AfterFilter[b][a][r]; // 将累积值映射到0-255的范围（可以根据实际情况调整比例） int intensity = static_cast&lt;int&gt;(255.0 * accumulator_value / 255.0); parameter_space_image.at&lt;uchar&gt;(b, a) = intensity; &#125; &#125; &#125; Mat enlargedHoughSpace; resize(parameter_space_image, enlargedHoughSpace, Size(width * thetaScale, height), 0, 0, INTER_LINEAR); Mat colorHoughSpace; applyColorMap(enlargedHoughSpace, colorHoughSpace, COLORMAP_JET); namedWindow(&quot;Detected Circles&quot;, WINDOW_NORMAL); imshow(&quot;Detected Circles&quot;, colorHoughSpace); imwrite(file_name, colorHoughSpace); waitKey(0);&#125;void ToughTransform::DrawCircleDetectedImage(Mat&amp; Image,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; PS_AfterFilter, int max_a, int max_b, int max_r, int second_filter_threshold)&#123; //threshold-filter-second vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; PS_FinalFilter(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); for (int i = 0; i &lt; PS_AfterFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_AfterFilter[0].size(); j++)&#123; for (int k = 0; k &lt; PS_AfterFilter[0][0].size(); k++)&#123; if(PS_AfterFilter[i][j][k] &gt;= second_filter_threshold) PS_FinalFilter[i][j][k] = PS_AfterFilter[i][j][k]; else PS_FinalFilter[i][j][k] = 0; &#125; &#125; &#125; ShowParameterSpace_Circle(PS_FinalFilter,&quot;source/circle-result/EnhancedHoughSpaceImage-FinalFilter.png&quot;); for (int i = 0; i &lt; PS_FinalFilter.size(); i++)&#123; for (int j = 0; j &lt; PS_FinalFilter[0].size(); j++)&#123; for (int k = 0; k &lt; PS_FinalFilter[0][0].size(); k++)&#123; //draw circle if(PS_FinalFilter[i][j][k] != 0)&#123; Point center(j, i); circle(Image, center, k, cv::Scalar(0, 0, 255), 2); //红色圆圈 &#125; &#125; &#125; &#125; namedWindow(&quot;Detected Circles&quot;, WINDOW_NORMAL); imshow(&quot;Detected Circles&quot;, Image); imwrite(&quot;source/circle-result/DrawCircleDetectedImage.png&quot;, Image); waitKey(0);&#125;/* CircleDetection: ShowParameterSpace_Circle + DrawCircleDetectedImage*/void ToughTransform::CircleDetection(Mat&amp; Image)&#123; //在霍夫变换中，我们通过三个参数来描述一个圆：圆心的坐标(a,b)和半径r. int img_width = Image.size().width; int img_height = Image.size().height; //ParameterSpace[b][a][r] b---&gt;height---&gt;y | a---&gt;width---&gt;x int max_a = img_width; int max_b = img_height; int max_r = static_cast&lt;int&gt;(0.5* min(max_a,max_b)); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; ParameterSpace(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); for (int y = 0; y &lt; img_height; y++)&#123; for (int x = 0; x &lt; img_width; x++)&#123; int B = Image.at&lt;Vec3b&gt;(y,x)[0]; int G = Image.at&lt;Vec3b&gt;(y,x)[1]; int R = Image.at&lt;Vec3b&gt;(y,x)[2]; if(B == 0 &amp;&amp; G == 0 &amp;&amp; R == 0)&#123; //Edge is black-pixel //遍历r，计算row，存入参数空间: min_r = 20 --&gt; max_r for(int r = 20; r &lt;= max_r; r++)&#123; //遍历每个r情况下的theta(一周)，计算a&amp;b，存入参数空间 for(int theta = 0; theta &lt; 360; theta++)&#123; double theta_rad = theta * PI / 180.0; int a = static_cast&lt;int&gt;(x - r * cos(theta_rad)); int b = static_cast&lt;int&gt;(y - r * sin(theta_rad)); if(a &gt;= 0 &amp;&amp; a &lt; max_a &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; max_b)&#123; ParameterSpace[b][a][r]++; &#125; &#125; &#125; &#125; &#125; &#125; //threshold-filter int threshold = 10; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; PS_AfterFilter(max_b, vector&lt;vector&lt;int&gt;&gt;(max_a, vector&lt;int&gt;(max_r) )); //threshold-filter for (int i = 0; i &lt; ParameterSpace.size(); i++)&#123; for (int j = 0; j &lt; ParameterSpace[0].size(); j++)&#123; for (int k = 0; k &lt; ParameterSpace[0][0].size(); k++)&#123; if(ParameterSpace[i][j][k] &gt;= threshold) PS_AfterFilter[i][j][k] = ParameterSpace[i][j][k]; else PS_AfterFilter[i][j][k] = 0; &#125; &#125; &#125; ShowParameterSpace_Circle(PS_AfterFilter,&quot;source/circle-result/EnhancedHoughSpaceImage-FirstFilter.png&quot;); const int second_filter_threshold = 300; DrawCircleDetectedImage(Image,PS_AfterFilter,max_a,max_b,max_r,second_filter_threshold);&#125;int main()&#123; ToughTransform handle; //Mat img = imread(&quot;source/line.png&quot;); //LineDetection(img); //Mat img2 = imread(&quot;source/testline_cross.png&quot;); //LineDetection(img2); Mat img3 = imread(&quot;source/line_circle.png&quot;); //handle.LineDetection(img3); handle.CircleDetection(img3); return 0;&#125;","categories":[{"name":"LAB EXERCISE","slug":"LAB-EXERCISE","permalink":"https://shinononome-enana.github.io/categories/LAB-EXERCISE/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://shinononome-enana.github.io/tags/CPP/"},{"name":"Tough-Transform","slug":"Tough-Transform","permalink":"https://shinononome-enana.github.io/tags/Tough-Transform/"}]},{"title":"寄存器堆(RegisterFile)的设计和仿真验证","slug":"RegisterFile","date":"2024-11-03T04:43:31.000Z","updated":"2025-01-03T13:07:03.744Z","comments":true,"path":"2024/11/03/RegisterFile/","permalink":"https://shinononome-enana.github.io/2024/11/03/RegisterFile/","excerpt":"","text":"RF4x8模块硬件描述基本功能描述： 读写全双工。写入数据需要①拉高一位使能信号en_wr并②给定地址Addr_wr和③数据Data_wr；读取数据需要给定地址Addr_rd_X，并支持两路读取(X&#x3D;A&#x2F;B)。 数据位宽：8bit；地址位宽：4bit，地址总数2^4&#x3D;16个。即本RF4x8中可以存放16个8bit数据。 时序：clk上升沿检测钟控；rst下降沿检测，异步复位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module RF4x8 #( parameter DATA_WIDTH = 8, ADDR_WIDTH = 4)( input wire clk, input wire rst, input wire en_wr, input wire[DATA_WIDTH-1:0] Data_wr, //写数据：位宽为8bit input wire[ADDR_WIDTH-1:0] Addr_wr, //写地址：地址位宽为4bit,因此总地址数量为2^4 = 16 input wire[ADDR_WIDTH-1:0] Addr_rd_A, //读地址A input wire[ADDR_WIDTH-1:0] Addr_rd_B, //读地址B output reg[DATA_WIDTH-1:0] Data_rd_A, output reg[DATA_WIDTH-1:0] Data_rd_B);reg[2**ADDR_WIDTH-1:0] addr;reg[DATA_WIDTH-1:0] data[0:2**ADDR_WIDTH-1]; //[7:0] data[0:15] -&gt; 16个地址，每个地址下存储一个8bit数据//reset:清空数据integer i;always@(posedge clk or negedge rst)begin if(!rst) begin for(i=0; i&lt;2**ADDR_WIDTH; i=i+1) data[i] &lt;= 8&#x27;b0000_0000; endend//写数据always@(posedge clk)begin if(en_wr) //写使能en_wr==1&#x27;b1 data[Addr_wr] &lt;= Data_wr; else data[Addr_wr] &lt;= data[Addr_wr];end//读数据always@(posedge clk)begin Data_rd_A &lt;= data[Addr_rd_A]; //A通道 Data_rd_B &lt;= data[Addr_rd_B]; //B通道endendmodule RF4x8仿真分析仿真模块RF4x8_tb12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061`timescale 1ns / 10psmodule RF4x8_tb();parameter DATA_WIDTH = 8;parameter ADDR_WIDTH = 4;reg clk,rst;reg en_wr;reg[DATA_WIDTH-1:0] Data_wr;reg[ADDR_WIDTH-1:0] Addr_wr;reg[ADDR_WIDTH-1:0] Addr_rd_A,Addr_rd_B;wire[DATA_WIDTH-1:0] Data_rd_A,Data_rd_B;initial begin clk &lt;= 1&#x27;b0; rst &lt;= 1&#x27;b1; en_wr &lt;= 1&#x27;b0;endalways #10 clk &lt;= ~clk;initial begin $monitor(&quot;%t Data_rd_A=%b Data_rd_B=%b&quot;,$time,Data_rd_A,Data_rd_B); #10 rst &lt;= 1&#x27;b0; #10 rst &lt;= 1&#x27;b1; //测试写入 #20 en_wr &lt;= 1&#x27;b1; Addr_wr &lt;= 4&#x27;b0000; Data_wr &lt;= 8&#x27;b1001_0011; #20 en_wr &lt;= 1&#x27;b1; Addr_wr &lt;= 4&#x27;b0001; Data_wr &lt;= 8&#x27;b1111_0000; #20 en_wr &lt;= 1&#x27;b1; Addr_wr &lt;= 4&#x27;b1100; Data_wr &lt;= 8&#x27;b0000_1011; #20 en_wr &lt;= 1&#x27;b1; Addr_wr &lt;= 4&#x27;b1111; Data_wr &lt;= 8&#x27;b0100_1111; //测试读取 en_wr &lt;= 1&#x27;b0; #20 Addr_rd_A &lt;= 4&#x27;b0000; Addr_rd_B &lt;= 4&#x27;b0000; #20 Addr_rd_A &lt;= 4&#x27;b0000; Addr_rd_B &lt;= 4&#x27;b0001; #20 Addr_rd_A &lt;= 4&#x27;b1111; Addr_rd_B &lt;= 4&#x27;b1100; //测试读写双全工 #20 en_wr &lt;= 1&#x27;b1; Addr_wr &lt;= 4&#x27;b0101; Data_wr &lt;= 8&#x27;b1111_1111; #20 Addr_rd_A &lt;= 4&#x27;b0101; Addr_rd_B &lt;= 4&#x27;b0101; #50 //测试复位 #10 rst &lt;= 1&#x27;b0; en_wr &lt;= 1&#x27;b0; Addr_wr &lt;= 4&#x27;bx; Data_wr &lt;= 8&#x27;bx; #10 rst &lt;= 1&#x27;b1; #20 Addr_rd_A &lt;= 4&#x27;b0101; Addr_rd_B &lt;= 4&#x27;b0101; #20 $finish;endRF4x8 RF4x8_for_simultion( .clk(clk), .rst(rst), .en_wr(en_wr), .Data_wr(Data_wr), .Addr_wr(Addr_wr), .Addr_rd_A(Addr_rd_A), .Addr_rd_B(Addr_rd_B), .Data_rd_A(Data_rd_A), .Data_rd_B(Data_rd_B) );endmodule 仿真结果时序分析 40ns,60ns,80ns,100ns时写数据：拉高写使能信号en_wr,分别向地址0000,0001,1100和1111写入数据10010011,11110000,00001011和01001111。写地址和写数据信号分别在50ns,70ns,90ns和110ns时刻的clk上升沿被捕捉到。 120ns时读数据：给出A&#x2F;B端口读数据地址0000和0000,并在130ns的clk上升沿被捕捉(图1中粉色虚线所在位置),Data_rd_A&#x2F;Data_rd_B分别读取到地址0000处的数据10010011。 130ns时读数据：改变B端口读地址为0001,在140ns的clk上升沿被捕捉,Data_rd_B读取到地址0001处的数据11110000。 260ns时发生复位：rst被拉低(图2中黄色实线所在位置)，此时再读地址0101的数据，发现被重置为00000000。 注： 本测试例中，读地址给出后需要等待半个时钟周期才能读出数据，这是因为读地址信号刚好和clk错开(读地址信号给出时正好是clk下降沿)，需要等待clk到达上升沿才能捕捉到读地址信号。如果读写信号再延时半个时钟周期，那么不会出现这样的情况。 关于写使能信号en_wr：虽然支持读写双工，但在读数据时最好要把en_wr拉低。否则当RF与其他模块级联时，可能会导致RF在被读的同时被写入不正确的数据，这在后面的RF_ALU级联测试中会提到。","categories":[{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"},{"name":"System LSI Design","slug":"Course-Assignment/System-LSI-Design","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/System-LSI-Design/"}],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"https://shinononome-enana.github.io/tags/Verilog/"}]},{"title":"有关日语中「と」和「という」文法的一些理解","slug":"hinongo01","date":"2024-10-28T12:30:25.000Z","updated":"2025-03-26T13:25:10.694Z","comments":true,"path":"2024/10/28/hinongo01/","permalink":"https://shinononome-enana.github.io/2024/10/28/hinongo01/","excerpt":"","text":"日本人说话时句末的「と」是什么意思？这个问题是我在做JLPT-N2的完形填空时发现的，当时文章中有这么一句话： 時には、「陰口」が聞こえてくるかもしれない。「彼は、わがままだよな」「あいつはいつも定時だね」などと。 当时我就很不理解这个「など」后面的「と」是什么意思，导致整段理解吃力。后来我去问了实验室里一个日本语上手的学长，才明白了这个用法的实际含义。 「と」放在句末：转述别人说的话，或者是引用别人说的话。可以理解成「と言います」的省略。 在N4语法中有这么一条，叫 「と言います」表示“传闻，听说…”。 而省略后的「と」更多地用在转述他人说的话的场合上。因此，「と言います」与句尾的「と」的含义还是有细微的区别，但可以连携记忆。下面举一个「と言います」表示“传闻，听说…”的例文，同样也是出现在N2考题中的： 最近はインタネットを通じて知り合った人と結婚することも多いという。 （翻译） (听说)进来通过网络认识并结婚的人也很多。 理解了这一点，我们就知道了文章中这句话的意思： 時には、「陰口」が聞こえてくるかもしれない。「彼は、わがままだよな」「あいつはいつも定時だね」などと。很多时候，我们可能会听到别人在暗地里的议论之词，“他这个人可真是任性啊”“那个家伙每次可都准时(下班)呢”种种。 因为「彼は、わがままだよな」「あいつはいつも定時だね」这两句话是从别人口中说出的，文章引用他们的话，所以最后加了个「と」，表示“别人说……” 我们可以再举几个简单的情景对话例子，来理解这个句末的「と」。 由于上周太浪的缘故，导致你的科研毫无进展，这周组会上被教授严厉地批评了一通。组会结束后，你的同学和你交谈了起来： ー なんでそんなに元気がない様子？ ー だって、先生が「来週頑張らなければ学校辞めろう！」と。（翻译） —— 为什么看起来这么没精神？ —— 因为老师说“下周再不努力的话就退学吧！” 你有个好哥们暗恋一个女生，想送她生日礼物，但是他太怂了不敢问她喜欢什么东西，因此拜托你去打听一下。打听结束后，你们在交谈： ー 何が情報があるんだか？ ー 「可愛いウサギのバックが好きだ」と。(翻译) —— 得到什么情报没有？ —— 她说她喜欢可爱兔兔的包包。 在原神的角色PV：纳西妲「生日快乐」中，纳西妲念的诗歌也用到了这个「と」： 花車が揺らぎ、ナヒーダは目を開ける。そして言う、夢を見ていたと。ナヒーダの誕生日は今日なのだと。(翻译)花车摇呀摇，纳西妲睁开眼。她说：刚刚做了梦，梦见纳西妲的生日就是今天。 这个文法(或许也不能称之为文法)大概率是不会出现在语法书上的，但是在日本人日常的对话中非常常见，来日本的这一个多月里也时常会听到身边的日本人说。 日本人的口癖：「というふうに」・「という感じで」这几周每周三晚上我都会有一节Digital Circuit的课，我发现教授在上课时经常会说这样几个短语： （哔哩吧啦解释一大堆专业性概念后）…というふうになって…（哔哩吧啦解释一大堆专业性概念后）…という感じで… 于是我就去搜索了一下「というふうに」的意思，发现它是很多很多日本人说话时都会有的口癖。 首先，「ふう」的汉字是「風」，在字典里有解释是“样子；方法”。因此,「というふうに」就可以解释成 “就像说的这个样子一样…”，“就像这样…” 。 其次，在文法层面 「ふうに」＝「ように」，「感じで」也有类似的感觉。因此可以用几个最常用的句型来记忆它。 こんなふうにやってみます！ こんな感じでやってみます！ このようにやってみます！ (翻译) 就这样做做看吧！ 另外，「というふうに」虽然是口癖，给人一种非常口语化、不正式的感觉，但其实现在很多正式的场合也会用到「というふうに」。可能是语言也在慢慢地演化吧。 下面这个视频可以很好地进行解释： 「という」视作前置定语的引导词：概述前面，修饰后面在前两节，我们提到了由「といいます」简化而成的口语「と」，也总结了日本人的口癖用法「というふうに」。但他们归根结底的词根用法是「という」。研究过N2&#x2F;N1语法书的人都知道，由「という」引申出去的文法实在是多的可怕，比如「というより…」「~ということ」。这些复杂且需要额外区分的复杂文法总结，放在了这一节的最后部分。在这一节的主体部分，我只想讨论「という」最基础的含义。 「いう」写作汉字是「言う」，意思是“说”，只要是学过日语的人都知道。因此，不难理解 「という」的本意就是「叫做…」「称作…」。 与「という」组合而成的文法看似纷繁复杂，其实只要抓住一点就不难理解了，以下面这个句子为例： 勝つのは難しいかもしれないが、まったく可能性がないというわけでもない。 此处的「という」很显然是对前面「勝つ可能性がない」这个事情&#x2F;观点的总结，然后修饰后面的「わけ」。“没有赢的可能性”这样的“情况”，也并非如此。人话就是虽然难赢但还是可能赢的。当然，把「～というわけでもない」当做一个固定短语“并不是说…”记忆也可以，但重要的是要理解语法现象。 「という」概述前面，修饰后面的名词。从前面的描述&#x2F;观点一直到「という」为止，都可以试做后面名词的前置定语。我们可以这样认为：「という」是一种前置定语的引导词。 从这一观点出发，再去思考上一节的「というふうに」，发现也是如此。类似的还可以举出很多例句： 私の趣味は旅行ということです。彼が言ったことを信じるのは難しいが、それが真実だという可能性もある彼女が新しいプロジェクトのリーダーになるという話を聞いたが、具体的な詳細はまだ不明だ。 「という」在口语中省略为「って」另外，「という」在口语里常常会省略成「って」,这里的「という」则是「と言います」表示“传闻，听说…”。这是一个N4的语法，再此稍作复习，不做具体展开讨论。 彼女は先月結婚したって知ってるか？ &#x2F; 彼女は先月結婚したという。彼は本当にすごい人だって。 &#x2F; 彼は本当にすごい人だという。 私は字がきれいですって。きれいなもんですか。你说我的字写的好看？哪儿好看了。","categories":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"}]},{"title":"VOCALOID调教之十二大参数","slug":"VOCALOID调教之十二大参数","date":"2024-10-27T11:05:00.000Z","updated":"2024-10-28T08:32:46.569Z","comments":true,"path":"2024/10/27/VOCALOID调教之十二大参数/","permalink":"https://shinononome-enana.github.io/2024/10/27/VOCALOID%E8%B0%83%E6%95%99%E4%B9%8B%E5%8D%81%E4%BA%8C%E5%A4%A7%E5%8F%82%E6%95%B0/","excerpt":"","text":"VOCALOID调教之十二大参数前言​ 在钢琴窗口之下的调参区，左侧点击Edit，可以切换选择待调整的参数。 VEL：速度​ VEL参数主要调整“辅音长度”，即咬字的清晰度。辅音往往先于整个字的音所在节拍而发出的。换句话讲，任何一个字在歌唱时，辅音先发声，并且辅音的发声要略早于整个音符的起点。 VEL调高：咬字比较轻，基本听不到辅音的发声。 VEL调低：咬字很重，用于强调本音。 ​ 全曲的VEL参数建议错落有致地进行设置，最好不要连续地将VEL拉高或者拉低。如果VEL连续地拉高，那么这一段的每个字都听上去轻飘飘的，连续的咬字不清也会带来听不懂的问题；如果VEL连续地拉低，听上去像是一个字一个字顿着发出的声音，MIKU或者洛天依像是在咬牙切齿地唱。如果不是为了风格有意而为之，建议不要这样。 DYN：动态​ DYN参数最直观的影响是音符的响度，调教初期可以不调整这个参数。刻意地进行DYN的调整，某些歌姬可能会出现非常不好的效果。比如可能造成歌姬人声的响度忽高忽低，时而盖过伴奏时而又被伴奏淹没。这样听上去就非常的难受了。 ​ 有时通过DYN的调整，也可以实现个人独特的风格。但难度较大。 BRE：呼吸度​ BRE参数调整音色的“粗糙程度”。默认值为0。 BRE调高：声音变得干涩，沙哑。 BRE调低：声音变得明亮一些。 ​ 一般而言，要求全段BRE保持一致。 BRI：明亮度​ BRI参数调整声音的“明亮度”。声音明暗的变化可以调整歌姬演唱情绪的起伏，要经常进行调教。 BRI调高：声音变得明亮，像是张大嘴巴放声歌唱。 BRI调低：声音变得低沉，像是压在喉咙里放不开的声音。 ​ 在调整BRI时，一个音的响度和频率都发生了较大的变化。具体而言，声音调整的越明亮，频谱整体就会向高频偏移；反之亦然。另外，BRI的调整基本不会影响辅音，但是BRI太低可能会导致齿音较重的问题（尤其是洛天依）。 CLE：清晰度​ CLE调高后，声音会变得锋利。基本不作调整。 OPE：开口度​ OPE默认拉满，只能向下降低调整。但是如果将一整个音的开口度都设置小，运用于某些长音就不适合，歌姬就像是含着东西在发声一样，听起来很奇怪。如果想要调整全曲歌姬演唱的口型，单纯设置OPE不能解决问题，只能拆音。 GEN：性别值​ 调整歌姬音色的共振峰，让声音更偏向于男声或者女声。这个参数通常全段一致处理，不对每个字进行单修。 GEN调高：声音变粗，更像男声。但是鼻音增大，声音会变软一些。 GEN降低：声音变细，更像女声。 POR：滑音时间​ 在音符与音符之间的衔接处，会有衔接的滑音。比如从C3-do升高到mi，歌姬的音调并不是阶跃式的抬升，而是平滑地向上增加。调整POR前可以先开启“音高渲染”，将音高线显示在音符上，会更加直观。 POR调高：前一个音符会更慢地划向后一个。 POR调低：前一个音符会更快地划向后一个。 ​ POR一般不需要大动，个别字精修就行了，整体调整会导致歌姬发声的不自然。 XSY：交叉演奏参数​ XSY参数用于混合两个歌姬的声线，其常规用法是混合同一个歌姬的不同声线。比如，用不同比例混合洛天依的meng和ning的音色。XSY主要用于解决一个歌姬的音域问题，比如洛天依可以在高音部分混合一些乐正绫进行改善。 ​ 调整前首先需要设置“第二歌手”：【设置】–【当前歌手属性(A)】–【双击当前歌手】–【第二歌手】 XSY越大：第二歌手的影响就更大。 ​ 一个歌姬的第二歌手由官方给定并限制，如果我们想要混合其他同语种的歌姬，可以在V4编辑器的声库管理工具Vocaloid Voice Management中进行解锁。另外，这是V4编辑器特有的功能，在V5和V6编辑器中反而删除了这个功能。 GWL：咆哮声PIT：滑音​ PIT参数用于调整“音高”，是最重要的参数。其直观效果是： 从中线向下拉低一半：降低一个半音。 从中线向下拉低到底：降低两个半音。 ​ PIT的调教是VOCALOID调教的核心，也是一个调教师水平和风格的最直观体现。PIT的变化对歌曲的情绪等方面都有着很大的影响。其它参数多如牛毛的微调，有时可能还没有PIT的一笔来得有效果。PIT还可以控制转音和颤音。 ​ 另外，PIT的功能很强大，比如我们可以用PIT手绘颤音：","categories":[{"name":"VOCALOID","slug":"VOCALOID","permalink":"https://shinononome-enana.github.io/categories/VOCALOID/"}],"tags":[{"name":"vocaloid","slug":"vocaloid","permalink":"https://shinononome-enana.github.io/tags/vocaloid/"}]},{"title":"CPP实现蚁群算法(ACO)并解决TSP问题","slug":"TSP-CPP","date":"2024-10-22T10:05:24.000Z","updated":"2024-10-28T08:41:01.313Z","comments":true,"path":"2024/10/22/TSP-CPP/","permalink":"https://shinononome-enana.github.io/2024/10/22/TSP-CPP/","excerpt":"","text":"问题简述Given a set of n nodes and distances for each pair of nodes, find aroundtrip of minimal total length visiting each node exactly once. The distance from node i to node j is the same as from node j to node i. Berlin52 – 52 locations in Berlin (Germany) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;chrono&gt;using namespace std;//Super-Parametersconst int ITERATION_TIMES = 200;const int ANT_NUMBER = 100;const int CITY_NUMBER = 50; //DataSet: Berin52const double ALPHA = 2.0;const double BETA = 1.0;const double ROW = 0.4;const double information_init = 1.14;typedef vector&lt;vector&lt;double&gt;&gt; Matrix; struct Ant&#123; vector&lt;int&gt; route; //(目前为止)路径 double TotalRouteLength; //(目前为止)路径的总长度&#125;;class TSP&#123; public: TSP(Matrix DistancesMatrix) : DistancesMatrix(DistancesMatrix)&#123; city_number = DistancesMatrix.size(); //城市数量：通过距离矩阵获取 InformationMatrix = Matrix(city_number,vector&lt;double&gt;(city_number,information_init)); //初始化信息素矩阵 &#125; void solve(); //获取最佳情况 double GetBestRouteLength(); vector&lt;int&gt; GetBestRoute(); private: //存储最佳情况 double BestRouteLength = numeric_limits&lt;double&gt;::max(); //初始值需要赋予一个很大的值 vector&lt;int&gt; BestRoute; //一般参数 int city_number; //距离矩阵，信息素矩阵 Matrix DistancesMatrix; Matrix InformationMatrix; //三个核心方法 int Select_NextCity(Ant&amp; this_ant); //传入Ant结构体的一个对象 double Calculate_TotalLength(Ant&amp; this_ant); void Update_Information(vector&lt;Ant&gt;&amp; ants);&#125;;/* TSP的主要算法流程---------------------------------*/void TSP::solve()&#123; for(int iter=0; iter&lt;ITERATION_TIMES; iter++)&#123; cout &lt;&lt; &quot;------第&quot; &lt;&lt; iter+1 &lt;&lt; &quot;次算法迭代&quot; &lt;&lt; &quot;------&quot; &lt;&lt; endl; vector&lt;Ant&gt; ants(ANT_NUMBER); //####创建存放Ant结构体变量的数组，开辟的空间数量为ANT_NUMBER for(int i = 0; i &lt; ANT_NUMBER; i++)&#123; //第i只蚂蚁 ants[i].route.push_back(rand() % city_number); //Step1:初始化蚂蚁所在节点（随机） cout &lt;&lt; &quot;|||第&quot; &lt;&lt; i+1 &lt;&lt; &quot;只蚂蚁：初始位置为&quot; &lt;&lt; ants[i].route.back() &lt;&lt; &quot;|||&quot; &lt;&lt; endl; for(int j = 0; j &lt; city_number - 1; j++)&#123; //第j步移动 int nextCity = Select_NextCity(ants[i]); //Step2:选择下一个前往的节点,结果push到route集合中去。重复直到走遍所有节点。#核心：Select_NextCity()方法 ants[i].route.push_back(nextCity); cout &lt;&lt; &quot;!!!第&quot; &lt;&lt; j+1 &lt;&lt; &quot;步:移动到&quot; &lt;&lt; nextCity &lt;&lt; endl; &#125; ants[i].TotalRouteLength = Calculate_TotalLength(ants[i]); //Step3:计算该蚂蚁(i)当前路径下的总距离，然后看看是不是最佳情况。#核心：Calculate_TotalLength()方法 cout &lt;&lt; &quot;--&gt;路径长：&quot; &lt;&lt; ants[i].TotalRouteLength &lt;&lt; endl; if(ants[i].TotalRouteLength &lt; BestRouteLength) &#123; BestRouteLength = ants[i].TotalRouteLength; BestRoute = ants[i].route; &#125; cout &lt;&lt; &quot;目前为止最佳的路径长：&quot; &lt;&lt; BestRouteLength &lt;&lt; endl; &#125; //Step4:所有蚂蚁的情况运行结束，现在开始根据ants所有成员存储的route信息，更新信息素矩阵。#核心：Update_Information()方法 Update_Information(ants); //Step5:本次迭代结束，进入下一个迭代。 &#125;&#125;/* Select_NextCity:路径选择*/int TSP::Select_NextCity(Ant&amp; this_ant)&#123; //this_ant.route存储了已经经过的结点，类型是vector&lt;int&gt;。在选择下一个目的节点时，需要跳过这些节点。 //创建概率列表Probabilities：从当前节点i往其他节点走的概率p_k(i,j) vector&lt;double&gt; Probabilities(city_number,0.0); int NowCity = this_ant.route.back(); //NowCity：当前所在的节点，即route列表的最后一项 double totalProbabilities = 0.0; //Step1: 计算每个情况的概率(分子) for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; //需要跳过已经访问的节点,前往他们的概率保持为0.0 auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; double information_goto_nextcity = InformationMatrix[NowCity][NextCity]; double distance_goto_nextcity = DistancesMatrix[NowCity][NextCity]; Probabilities[NextCity] = pow(information_goto_nextcity, ALPHA) * pow(1.0/distance_goto_nextcity, BETA); totalProbabilities += Probabilities[NextCity]; //cout &lt;&lt; &quot;#Probabilities:[Before]&quot; &lt;&lt; Probabilities[NextCity] &lt;&lt; endl; &#125; //cout &lt;&lt; &quot;#totalProbabilities:&quot; &lt;&lt; totalProbabilities &lt;&lt; endl; //Step2:计算每个情况的条件概率p_k(i,j) for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; Probabilities[NextCity] = Probabilities[NextCity] / totalProbabilities; //cout &lt;&lt; &quot;#Probabilities:[After]&quot; &lt;&lt; Probabilities[NextCity] &lt;&lt; endl; &#125; //Step3:轮盘赌选择去往的下一个节点 double randVal = (double)rand() / RAND_MAX * totalProbabilities; //cout &lt;&lt; &quot;#randVal:&quot; &lt;&lt; randVal &lt;&lt; endl; for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; randVal -= Probabilities[NextCity] * totalProbabilities; if (randVal &lt;= 0)&#123; return NextCity; &#125; &#125; return -1; //ERROR&#125;/* Calculate_TotalLength:计算路径总长*/double TSP::Calculate_TotalLength(Ant&amp; this_ant)&#123; double totalLength = 0.0; for(int i = 0; i &lt; this_ant.route.size()-1; i++)&#123; totalLength += DistancesMatrix[this_ant.route[i]][this_ant.route[i+1]]; &#125; totalLength += DistancesMatrix[this_ant.route.back()][this_ant.route[0]]; //终点回到起点 return totalLength;&#125;/* Update_Information:更新信息素矩阵*/void TSP::Update_Information(vector&lt;Ant&gt;&amp; ants)&#123; //Step1: 信息素蒸发 for(int i = 0; i &lt; InformationMatrix[0].size(); i++)&#123; for(int j = 0; j &lt; InformationMatrix[0].size(); j++)&#123; InformationMatrix[i][j] = InformationMatrix[i][j] * (1 - ROW); &#125; &#125; //Step2: 信息素释放：每只蚂蚁经过的路径上，都会留下一定的信息素。留下信息素的量规定为距离的倒数 for(int i = 0; i &lt; ants.size(); i++)&#123; for(int j = 0; j &lt; ants[i].route.size() - 1; j++)&#123; int StartPoint = ants[i].route[j]; int Destination = ants[i].route[j+1]; InformationMatrix[StartPoint][Destination] += 1.0 / ants[i].TotalRouteLength; &#125; InformationMatrix[ants[i].route.back()][ants[i].route[0]] += 1.0 / ants[i].TotalRouteLength; //终点回到起点 &#125;&#125;vector&lt;int&gt; TSP::GetBestRoute()&#123; return BestRoute;&#125;double TSP::GetBestRouteLength()&#123; return BestRouteLength;&#125;int main()&#123; srand(static_cast&lt;unsigned&gt;(time(0))); //测试集要求：主对角线全0，其他元素不能出现0（否则两点就重合了，必定报错） /* Test: 5-CITY Matrix distances = &#123; &#123;0, 2, 9, 10, 7&#125;, &#123;1, 0, 6, 4, 3&#125;, &#123;15, 7, 0, 8, 6&#125;, &#123;6, 3, 12, 0, 5&#125;, &#123;10, 4, 8, 7, 0&#125; &#125;; */ Matrix distances = &#123; &#123;0, 2, 9, 10, 7, 4, 8, 12, 5, 6, 3, 15, 14, 11, 13, 9, 8, 7, 5, 6, 4, 3, 2, 1, 8, 9, 7, 5, 6, 12, 10, 14, 16, 8, 11, 9, 15, 10, 14, 6, 7, 5, 3, 8, 9, 10, 12, 11, 13, 9&#125;, &#123;2, 0, 6, 4, 3, 7, 5, 8, 9, 10, 11, 12, 13, 14, 15, 7, 8, 5, 6, 4, 3, 10, 12, 11, 9, 8, 6, 5, 7, 11, 12, 13, 14, 9, 8, 10, 11, 7, 5, 6, 4, 3, 9, 10, 8, 7, 6, 5, 4, 2&#125;, &#123;9, 6, 0, 8, 5, 12, 14, 11, 10, 9, 15, 6, 8, 7, 9, 8, 10, 12, 14, 15, 6, 7, 9, 11, 12, 13, 14, 16, 15, 12, 10, 9, 7, 8, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16&#125;, &#123;10, 4, 8, 0, 7, 9, 10, 12, 14, 11, 8, 7, 6, 5, 4, 8, 9, 10, 12, 11, 14, 13, 12, 15, 14, 11, 10, 8, 9, 10, 11, 12, 13, 14, 15, 16, 11, 10, 9, 12, 8, 7, 6, 5, 4, 3, 2, 1, 8, 7&#125;, &#123;7, 3, 5, 7, 0, 8, 9, 10, 12, 14, 11, 10, 9, 8, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 11, 10, 9, 8, 7, 6, 5, 4, 3&#125;, &#123;4, 7, 12, 9, 8, 0, 6, 10, 11, 13, 14, 15, 16, 12, 10, 9, 8, 7, 5, 4, 6, 5, 7, 9, 8, 10, 11, 12, 14, 15, 11, 10, 12, 13, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125;, &#123;8, 5, 14, 10, 9, 6, 0, 12, 11, 13, 14, 15, 16, 12, 11, 10, 9, 8, 7, 6, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4&#125;, &#123;12, 8, 11, 12, 10, 10, 12, 0, 14, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 10, 9, 8, 6, 7, 8, 10, 11, 12, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5&#125;, &#123;5, 9, 10, 14, 12, 11, 11, 14, 0, 6, 5, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 10, 12, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 9&#125;, &#123;6, 10, 9, 11, 14, 13, 12, 11, 6, 0, 5, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6&#125;, &#123;3, 11, 15, 8, 11, 14, 14, 9, 5, 5, 0, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 7, 6, 5, 4&#125;, &#123;15, 12, 6, 7, 10, 15, 15, 8, 9, 7, 7, 0, 3, 4, 5, 6, 8, 10, 12, 14, 15, 11, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5&#125;, &#123;14, 13, 8, 5, 9, 16, 12, 11, 8, 11, 9, 3, 0, 6, 7, 8, 9, 10, 12, 11, 14, 15, 14, 12, 10, 8, 6, 4, 3, 2, 1, 9, 10, 11, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 11, 10&#125;, &#123;11, 14, 7, 8, 6, 12, 11, 9, 10, 9, 8, 4, 6, 0, 2, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;, &#123;13, 15, 9, 4, 6, 15, 14, 6, 8, 8, 7, 5, 7, 2, 0, 5, 6, 7, 8, 9, 10, 11, 12, 10, 9, 8, 6, 4, 3, 2, 1, 11, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5&#125;, &#123;9, 7, 8, 8, 5, 11, 14, 9, 12, 11, 5, 6, 9, 5, 5, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16&#125;, &#123;8, 8, 10, 9, 4, 8, 12, 8, 9, 10, 8, 7, 10, 7, 6, 3, 0, 2, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2&#125;, &#123;7, 5, 12, 10, 1, 9, 10, 7, 10, 9, 8, 6, 8, 5, 6, 4, 2, 0, 4, 6, 8, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15, 16, 14, 12, 10, 9&#125;, &#123;5, 6, 14, 15, 4, 10, 9, 6, 8, 10, 6, 5, 11, 9, 8, 5, 4, 4, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13&#125;, &#123;6, 4, 15, 12, 6, 11, 12, 10, 11, 9, 5, 8, 12, 8, 9, 6, 6, 6, 2, 0, 2, 4, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15, 16&#125;, &#123;4, 3, 6, 4, 10, 5, 10, 8, 7, 10, 7, 5, 8, 9, 10, 9, 8, 6, 3, 2, 0, 3, 4, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14&#125;, &#123;3, 10, 7, 10, 9, 5, 9, 6, 8, 7, 3, 6, 10, 5, 5, 4, 3, 4, 4, 3, 3, 0, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14&#125;, &#123;2, 12, 9, 12, 8, 7, 8, 9, 10, 6, 7, 9, 12, 11, 10, 5, 6, 6, 4, 3, 2, 4, 0, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14&#125;, &#123;1, 11, 11, 15, 7, 6, 7, 10, 7, 11, 6, 5, 10, 8, 9, 6, 5, 10, 3, 2, 1, 5, 5, 0, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11&#125;, &#123;8, 9, 12, 14, 6, 10, 11, 12, 6, 7, 8, 7, 9, 12, 10, 9, 8, 8, 6, 4, 3, 6, 7, 3, 0, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15&#125;, &#123;9, 8, 12, 11, 5, 10, 10, 11, 8, 9, 9, 10, 11, 9, 8, 6, 5, 10, 2, 1, 10, 7, 8, 4, 8, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10&#125;, &#123;7, 6, 14, 15, 8, 9, 12, 11, 7, 10, 11, 9, 10, 8, 9, 8, 6, 9, 1, 1, 11, 10, 7, 7, 9, 3, 0, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2&#125;, &#123;6, 5, 11, 12, 7, 6, 9, 8, 10, 8, 10, 10, 10, 7, 6, 6, 5, 10, 4, 3, 1, 5, 4, 5, 10, 2, 3, 0, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;, &#123;5, 6, 12, 10, 4, 5, 9, 10, 11, 10, 10, 9, 10, 8, 8, 8, 7, 8, 3, 4, 2, 7, 7, 8, 10, 3, 4, 4, 0, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4&#125;, &#123;4, 3, 10, 12, 7, 9, 11, 12, 9, 6, 7, 8, 8, 10, 9, 5, 4, 5, 2, 1, 10, 8, 6, 7, 8, 2, 3, 5, 2, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4&#125;, &#123;3, 2, 9, 14, 8, 11, 12, 10, 10, 9, 6, 8, 9, 7, 8, 5, 3, 6, 1, 1, 9, 7, 8, 5, 4, 2, 3, 6, 3, 3, 0, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4&#125;, &#123;2, 1, 10, 16, 7, 8, 14, 12, 8, 10, 9, 6, 10, 8, 7, 4, 2, 5, 2, 1, 9, 6, 7, 6, 5, 3, 4, 5, 4, 5, 4, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6&#125;, &#123;1, 10, 11, 15, 8, 8, 11, 13, 9, 7, 5, 4, 5, 7, 5, 3, 2, 4, 1, 1, 10, 5, 8, 7, 9, 4, 5, 6, 5, 4, 3, 4, 0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5&#125;, &#123;2, 1, 10, 15, 6, 8, 10, 8, 10, 10, 8, 5, 8, 5, 9, 4, 3, 3, 2, 2, 8, 5, 4, 5, 4, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125; &#125;; TSP tsp(distances); auto start = chrono::high_resolution_clock::now(); tsp.solve(); cout &lt;&lt; &quot;Running the algorithm...\\n&quot; &lt;&lt; flush; auto end = chrono::high_resolution_clock::now(); chrono::duration&lt;double&gt; duration = end - start; //程序运行时间 vector&lt;int&gt; BestRoute = tsp.GetBestRoute(); double BestRouteLength = tsp.GetBestRouteLength(); //Test Ouput cout &lt;&lt; &quot;Algorithm completed!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n\\n==============最终结果==============\\n&quot;; cout &lt;&lt; &quot;最佳路径：&quot;; for(int i = 0 ; i &lt; BestRoute.size() - 1; i++) &#123; cout &lt;&lt; BestRoute[i] &lt;&lt; &quot; -&gt; &quot;; &#125; cout &lt;&lt; BestRoute.back(); cout &lt;&lt; &quot;\\n最佳(最短)路径长：&quot;; cout &lt;&lt; BestRouteLength &lt;&lt; endl; cout &lt;&lt; &quot;============================||END.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;(本次运行超参数：&quot; &lt;&lt; &quot;--ITERATION_TIMES=&quot; &lt;&lt; ITERATION_TIMES &lt;&lt; &quot;--ANT_NUMBER&quot; &lt;&lt; ANT_NUMBER &lt;&lt; &quot;--ALPHA=&quot; &lt;&lt; ALPHA &lt;&lt; &quot;--BETA=&quot; &lt;&lt; BETA &lt;&lt; &quot;--ROW=&quot; &lt;&lt; ROW &lt;&lt; &quot;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;(程序运行时长：&quot; &lt;&lt; duration &lt;&lt; &quot; seconds)&quot; &lt;&lt; endl; return 0;&#125; 代码逻辑和解析—-&gt;2024.10.25更新完毕算法载体“蚂蚁”的结构体表征12345struct Ant&#123; vector&lt;int&gt; route; //(目前为止)路径 double TotalRouteLength; //(目前为止)路径的总长度&#125;; route: 路径，是一个存放int的一维vector。比如{3,2,1,4,5}，表示该蚂蚁的行走路径是3-&gt;2-&gt;1-&gt;4-&gt;5，蚂蚁当前正位于节点5。算法的运行过程中，在每只蚂蚁、每一次根据概率选择完毕下一个节点后，route需要在末尾实时存入(push_back)这个目的节点。 TotalRouteLength：每一次迭代完成后(即一只蚂蚁走遍了所有节点)，存放route路径的总长度。 距离矩阵和信息素矩阵1234typedef vector&lt;vector&lt;double&gt;&gt; Matrix;//距离矩阵，信息素矩阵Matrix DistancesMatrix;Matrix InformationMatrix; 矩阵的第i行第j列元素，表示从i节点到j节点“路径的距离”&#x2F;“路径上信息素的含量”。 DistancesMatrix是算法的输入，他反映了当前TSP问题的城市个数和它们之间的位置关系(彼此间的距离)； i-&gt;j与j-&gt;i路径相同只是方向相反，同一条路径上的距离和信息素都应该相同。因此，DistancesMatrix和InformationMatrix都是主对角线全0的对称矩阵。 算法主逻辑solve()12345678910111213141516171819202122void TSP::solve()&#123; for(int iter=0; iter&lt;ITERATION_TIMES; iter++)&#123; vector&lt;Ant&gt; ants(ANT_NUMBER); //####创建存放Ant结构体变量的数组，开辟的空间数量为ANT_NUMBER for(int i = 0; i &lt; ANT_NUMBER; i++)&#123; //第i只蚂蚁 ants[i].route.push_back(rand() % city_number); //Step1:初始化蚂蚁所在节点（随机） for(int j = 0; j &lt; city_number - 1; j++)&#123; //第j步移动 int nextCity = Select_NextCity(ants[i]); //Step2:选择下一个前往的节点,结果push到route集合中去。重复直到走遍所有节点。#核心：Select_NextCity()方法 ants[i].route.push_back(nextCity); &#125; ants[i].TotalRouteLength = Calculate_TotalLength(ants[i]); //Step3:计算该蚂蚁(i)当前路径下的总距离，然后看看是不是最佳情况。#核心：Calculate_TotalLength()方法 if(ants[i].TotalRouteLength &lt; BestRouteLength) &#123; BestRouteLength = ants[i].TotalRouteLength; BestRoute = ants[i].route; &#125; &#125; //Step4:所有蚂蚁的情况运行结束，现在开始根据ants所有成员存储的route信息，更新信息素矩阵。#核心：Update_Information()方法 Update_Information(ants); //Step5:本次迭代结束，进入下一个迭代。 &#125;&#125; 三重循环：最外层循环控制算法总迭代次数；i循环遍历每只蚂蚁；j循环控制每只蚂蚁进行寻路。 核心方法调用： Select_NextCity：传入当前蚂蚁(结构体)。因为结构体中包含了蚂蚁现在的位置信息now(route的末尾元素)，因此可以遍历计算概率p(now,next)，并通过轮盘赌选择下一步的节点编号next。 Calculate_TotalLength：最内j循环运行完毕，即当前蚂蚁已经走遍所有节点，运算总路径长。随后确认是否是最佳情况。 Update_Information：所有蚂蚁寻路完毕，本次迭代完成，根据每只蚂蚁的路径route更新信息素矩阵。 另外：ants为所有蚂蚁的集合，数据类型是存放结构体对象的一维vector。 *算法主逻辑手写版： 核心方法·其一：Select_NextCity路径选择1234567891011121314151617181920212223242526272829303132333435363738394041424344int TSP::Select_NextCity(Ant&amp; this_ant)&#123; //this_ant.route存储了已经经过的结点，类型是vector&lt;int&gt;。在选择下一个目的节点时，需要跳过这些节点。 //创建概率列表Probabilities：从当前节点i往其他节点走的概率p_k(i,j) vector&lt;double&gt; Probabilities(city_number,0.0); int NowCity = this_ant.route.back(); //NowCity：当前所在的节点，即route列表的最后一项 double totalProbabilities = 0.0; //Step1: 计算每个情况的概率(分子) for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; //需要跳过已经访问的节点,前往他们的概率保持为0.0 auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; double information_goto_nextcity = InformationMatrix[NowCity][NextCity]; double distance_goto_nextcity = DistancesMatrix[NowCity][NextCity]; Probabilities[NextCity] = pow(information_goto_nextcity, ALPHA) * pow(1.0/distance_goto_nextcity, BETA); totalProbabilities += Probabilities[NextCity]; &#125; //Step2:计算每个情况的条件概率p_k(i,j) for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; Probabilities[NextCity] = Probabilities[NextCity] / totalProbabilities; &#125; //Step3:轮盘赌选择去往的下一个节点 double randVal = (double)rand() / RAND_MAX * totalProbabilities; for(int NextCity = 0; NextCity &lt; city_number; NextCity++)&#123; auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity); if(visited != this_ant.route.end()) continue; randVal -= Probabilities[NextCity] * totalProbabilities; if (randVal &lt;= 0)&#123; return NextCity; &#125; &#125; return -1; //ERROR&#125; 计算每条路径的**概率p_k(i,j)**。注意需要事先排除已经走过的节点。 轮盘赌选择去往的下一个节点。 核心方法·其二：Calculate_TotalLength计算总长123456789double TSP::Calculate_TotalLength(Ant&amp; this_ant)&#123; double totalLength = 0.0; for(int i = 0; i &lt; this_ant.route.size()-1; i++)&#123; totalLength += DistancesMatrix[this_ant.route[i]][this_ant.route[i+1]]; &#125; totalLength += DistancesMatrix[this_ant.route.back()][this_ant.route[0]]; //终点回到起点 return totalLength;&#125; 为了简化代码，solve()在运行时不会让蚂蚁回到起点。但此处我们认为TSP问题仍需要走一个闭环，所以在运算路径总长时需要另外加上从终点(route最后一项)回到起点(route第一项)的距离。 核心方法·其三：Update_Information信息素更新12345678910111213141516171819void TSP::Update_Information(vector&lt;Ant&gt;&amp; ants)&#123; //Step1: 信息素蒸发 for(int i = 0; i &lt; InformationMatrix[0].size(); i++)&#123; for(int j = 0; j &lt; InformationMatrix[0].size(); j++)&#123; InformationMatrix[i][j] = InformationMatrix[i][j] * (1 - ROW); &#125; &#125; //Step2: 信息素释放：每只蚂蚁经过的路径上，都会留下一定的信息素。留下信息素的量规定为距离的倒数 for(int i = 0; i &lt; ants.size(); i++)&#123; for(int j = 0; j &lt; ants[i].route.size() - 1; j++)&#123; int StartPoint = ants[i].route[j]; int Destination = ants[i].route[j+1]; InformationMatrix[StartPoint][Destination] += 1.0 / ants[i].TotalRouteLength; &#125; InformationMatrix[ants[i].route.back()][ants[i].route[0]] += 1.0 / ants[i].TotalRouteLength; //终点回到起点 &#125;&#125; 信息素蒸发：根据超参数ROW，对上一次迭代后的信息素进行衰减操作。 信息素释放：根据本轮迭代下每只蚂蚁的路径情况，为每条路径增加信息素。每次增加的信息素量是route总长的倒数(即1&#x2F;TotalRouteLength)。 读取.tsp数据文件—-&gt;稍后更新Berlin52数据集测试情况—-&gt;稍后更新","categories":[{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"},{"name":"Computational Intelligence","slug":"Course-Assignment/Computational-Intelligence","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/Computational-Intelligence/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://shinononome-enana.github.io/tags/CPP/"},{"name":"TSP","slug":"TSP","permalink":"https://shinononome-enana.github.io/tags/TSP/"}]}],"categories":[{"name":"修士课题记录","slug":"修士课题记录","permalink":"https://shinononome-enana.github.io/categories/%E4%BF%AE%E5%A3%AB%E8%AF%BE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Ｎ２日本語勉強メモ","slug":"N２日本語勉強メモ","permalink":"https://shinononome-enana.github.io/categories/N%EF%BC%92%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8B%89%E5%BC%B7%E3%83%A1%E3%83%A2/"},{"name":"Linux","slug":"Linux","permalink":"https://shinononome-enana.github.io/categories/Linux/"},{"name":"Life in Japan","slug":"Life-in-Japan","permalink":"https://shinononome-enana.github.io/categories/Life-in-Japan/"},{"name":"Course Assignment","slug":"Course-Assignment","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/"},{"name":"System LSI Design","slug":"Course-Assignment/System-LSI-Design","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/System-LSI-Design/"},{"name":"LAB EXERCISE","slug":"LAB-EXERCISE","permalink":"https://shinononome-enana.github.io/categories/LAB-EXERCISE/"},{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/"},{"name":"VOCALOID","slug":"VOCALOID","permalink":"https://shinononome-enana.github.io/categories/VOCALOID/"},{"name":"Computational Intelligence","slug":"Course-Assignment/Computational-Intelligence","permalink":"https://shinononome-enana.github.io/categories/Course-Assignment/Computational-Intelligence/"}],"tags":[{"name":"Object Pose Prediction","slug":"Object-Pose-Prediction","permalink":"https://shinononome-enana.github.io/tags/Object-Pose-Prediction/"},{"name":"日本語","slug":"日本語","permalink":"https://shinononome-enana.github.io/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"},{"name":"linux","slug":"linux","permalink":"https://shinononome-enana.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://shinononome-enana.github.io/tags/ubuntu/"},{"name":"アルバイト","slug":"アルバイト","permalink":"https://shinononome-enana.github.io/tags/%E3%82%A2%E3%83%AB%E3%83%90%E3%82%A4%E3%83%88/"},{"name":"CPP","slug":"CPP","permalink":"https://shinononome-enana.github.io/tags/CPP/"},{"name":"Verilog","slug":"Verilog","permalink":"https://shinononome-enana.github.io/tags/Verilog/"},{"name":"travel","slug":"travel","permalink":"https://shinononome-enana.github.io/tags/travel/"},{"name":"Tough-Transform","slug":"Tough-Transform","permalink":"https://shinononome-enana.github.io/tags/Tough-Transform/"},{"name":"vocaloid","slug":"vocaloid","permalink":"https://shinononome-enana.github.io/tags/vocaloid/"},{"name":"TSP","slug":"TSP","permalink":"https://shinononome-enana.github.io/tags/TSP/"}]}