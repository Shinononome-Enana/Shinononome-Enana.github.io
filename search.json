[{"title":"有关日语中「と」和「という」文法的一些理解","url":"/2024/10/28/hinongo01/","content":"\n## 日本人说话时句末的「と」是什么意思？\n\n这个问题是我在做JLPT-N2的完形填空时发现的，当时文章中有这么一句话：\n> 時には、「陰口」が聞こえてくるかもしれない。「彼は、わがままだよな」「あいつはいつも定時だね」など**と**。\n\n当时我就很不理解这个「など」后面的「と」是什么意思，导致整段理解吃力。后来我去问了实验室里一个日本语上手的学长，才明白了这个用法的实际含义。\n\n**「と」放在句末：转述别人说的话，或者是引用别人说的话。可以理解成「と言います」的省略。** \n\n在N4语法中有这么一条，叫 **「と言います」表示“传闻，听说...”。** 而省略后的「と」**更多地用在转述他人说的话的场合上**。因此，「と言います」与句尾的「と」的含义还是有细微的区别，但可以连携记忆。下面举一个「と言います」表示“传闻，听说...”的例文，同样也是出现在N2考题中的：\n>　最近はインタネットを通じて知り合った人と結婚することも多い**という**。\n>  （翻译）\n>   (听说)进来通过网络认识并结婚的人也很多。\n\n理解了这一点，我们就知道了文章中这句话的意思：\n> 時には、「陰口」が聞こえてくるかもしれない。「彼は、わがままだよな」「あいつはいつも定時だね」など**と**。\n> 很多时候，我们可能会听到别人在暗地里的议论之词，“他这个人可真是任性啊”“那个家伙每次可都准时(下班)呢”种种。\n\n因为「彼は、わがままだよな」「あいつはいつも定時だね」这两句话是从别人口中说出的，文章引用他们的话，所以最后加了个「と」，表示“别人说......”\n\n我们可以再举几个简单的情景对话例子，来理解这个句末的「と」。\n\n- 由于上周太浪的缘故，导致你的科研毫无进展，这周组会上被教授严厉地批评了一通。组会结束后，你的同学和你交谈了起来：\n>　ー　なんでそんなに元気がない様子？\n>　ー　だって、先生が「来週頑張らなければ学校辞めろう！」**と**。\n> （翻译）\n>  —— 为什么看起来这么没精神？\n>  —— 因为老师说“下周再不努力的话就退学吧！”\n\n- 你有个好哥们暗恋一个女生，想送她生日礼物，但是他太怂了不敢问她喜欢什么东西，因此拜托你去打听一下。打听结束后，你们在交谈：\n>　ー　何が情報があるんだか？\n>　ー　「可愛いウサギのバックが好きだ」**と**。\n> (翻译)\n>  —— 得到什么情报没有？\n>  —— 她说她喜欢可爱兔兔的包包。\n\n这个文法(或许也不能称之为文法)大概率是不会出现在语法书上的，但是在日本人**日常的对话中非常常见**，来日本的这一个多月里也时常会听到身边的日本人说。\n\n--------------------------\n\n## 日本人的口癖：「というふうに」・「という感じで」\n\n这几周每周三晚上我都会有一节Digital Circuit的课，我发现教授在上课时经常会说这样几个短语：\n> （哔哩吧啦解释一大堆专业性概念后）...というふうになって...\n> （哔哩吧啦解释一大堆专业性概念后）...という感じで...\n\n于是我就去搜索了一下「というふうに」的意思，发现它是很多很多日本人说话时都会有的口癖。\n\n首先，「ふう」的汉字是「風」，在字典里有解释是“样子；方法”。因此,**「というふうに」就可以解释成 “就像说的这个样子一样...”，“就像这样...” 。**\n\n其次，在文法层面 **「ふうに」＝「ように」**，「感じで」也有类似的感觉。因此可以用几个最常用的句型来记忆它。\n>　こんな**ふうに**やってみます！\n>　こんな**感じで**やってみます！\n>　この**ように**やってみます！\n>    (翻译)\n>    就这样做做看吧！\n\n另外，「というふうに」虽然是口癖，给人一种非常口语化、不正式的感觉，但其实现在很多正式的场合也会用到「というふうに」。可能是语言也在慢慢地演化吧。\n\n<img src=\"https://s2.loli.net/2024/10/28/9WMIRrgQTlamADq.png\" style=\"zoom:65%;\" />\n\n下面这个视频可以很好地进行解释： \n<iframe \n    src=\"//player.bilibili.com/player.html?isOutside=true&aid=113334019951909&bvid=BV1DDCdYtEL1&cid=26365005117&p=1\" \n    width=\"900\" \n    height=\"550\" \n    scrolling=\"no\" \n    border=\"0\" \n    frameborder=\"no\" \n    framespacing=\"0\" \n    allowfullscreen=\"true\">\n</iframe>\n\n--------------------------\n\n## 「という」视作前置定语的引导词：概述前面，修饰后面\n\n在前两节，我们提到了由「といいます」简化而成的口语「と」，也总结了日本人的口癖用法「というふうに」。但他们归根结底的词根用法是「という」。研究过N2/N1语法书的人都知道，由「という」引申出去的文法实在是多的可怕，比如「というより...」「~ということ」。这些复杂且需要额外区分的复杂文法总结，放在了这一节的最后部分。在这一节的主体部分，我只想讨论「という」最基础的含义。\n\n「いう」写作汉字是「言う」，意思是“说”，只要是学过日语的人都知道。因此，不难理解 **「という」的本意就是「叫做...」「称作...」。** \n\n与「という」组合而成的文法看似纷繁复杂，其实只要抓住一点就不难理解了，以下面这个句子为例：\n> 勝つのは難しいかもしれないが、まったく可能性がない**というわけでもない**。\n\n此处的「という」很显然是**对前面「勝つ可能性がない」这个事情/观点的总结，然后修饰后面的「わけ」**。“没有赢的可能性”这样的“情况”，也并非如此。人话就是虽然难赢但还是可能赢的。当然，把「～というわけでもない」当做一个固定短语“并不是说...”记忆也可以，但重要的是要理解语法现象。\n\n**「という」概述前面，修饰后面的名词。从前面的描述/观点一直到「という」为止，都可以试做后面名词的前置定语。我们可以这样认为：「という」是一种前置定语的引导词。** 从这一观点出发，再去思考上一节的「というふうに」，发现也是如此。类似的还可以举出很多例句：\n> 私の趣味は旅行**ということ**です。\n> 彼が言ったことを信じるのは難しいが、それが真実だ**という可能性**もある\n> 彼女が新しいプロジェクトのリーダーになる**という話**を聞いたが、具体的な詳細はまだ不明だ。\n\n--------------------------\n\n## 「という」在口语中省略为「って」\n\n另外，**「という」在口语里常常会省略成「って」**,这里的「という」则是「と言います」**表示“传闻，听说...”。**这是一个N4的语法，再此稍作复习，不做具体展开讨论。\n\n> 彼女は先月結婚した**って**知ってるか？  /  彼女は先月結婚した**という**。\n> 彼は本当にすごい人だ**って**。   /  彼は本当にすごい人だ**という**。\n\n","tags":["日本語"],"categories":["日本語"]},{"title":"VOCALOID调教之十二大参数","url":"/2024/10/27/VOCALOID调教之十二大参数/","content":"\n# VOCALOID调教之十二大参数\n\n## 前言\n\n​\t在钢琴窗口之下的调参区，左侧点击Edit，可以切换选择待调整的参数。\n\n<img src=\"https://s2.loli.net/2024/10/28/W3dYeKOXfVbmvth.png\" style=\"zoom:50%;\" />\n\n## VEL：速度\n\n​\tVEL参数主要**调整“辅音长度”，即咬字的清晰度**。辅音往往先于整个字的音所在节拍而发出的。换句话讲，任何一个字在歌唱时，辅音先发声，并且辅音的发声要略早于整个音符的起点。\n\n- VEL调高：咬字比较轻，基本听不到辅音的发声。\n- VEL调低：咬字很重，用于强调本音。\n\n​\t全曲的VEL参数建议**错落有致地进行设置**，最好不要连续地将VEL拉高或者拉低。如果VEL连续地拉高，那么这一段的每个字都听上去轻飘飘的，连续的咬字不清也会带来听不懂的问题；如果VEL连续地拉低，听上去像是一个字一个字顿着发出的声音，MIKU或者洛天依像是在咬牙切齿地唱。如果不是为了风格有意而为之，建议不要这样。\n\n## DYN：动态\n\n​\tDYN参数最直观的影响是**音符的响度**，调教初期可以不调整这个参数。刻意地进行DYN的调整，某些歌姬可能会出现非常不好的效果。比如可能造成歌姬人声的响度忽高忽低，时而盖过伴奏时而又被伴奏淹没。这样听上去就非常的难受了。\n\n​\t有时通过DYN的调整，也可以实现个人独特的风格。但难度较大。\n\n## BRE：呼吸度\n\n​\tBRE参数调整**音色的“粗糙程度”**。默认值为0。\n\n- BRE调高：声音变得干涩，沙哑。\n- BRE调低：声音变得明亮一些。\n\n​\t一般而言，要求全段BRE保持一致。\n\n## BRI：明亮度  \n\n​\tBRI参数调整声音的**“明亮度”**。声音明暗的变化可以**调整歌姬演唱情绪的起伏**，要经常进行调教。\n\n- BRI调高：声音变得明亮，像是张大嘴巴放声歌唱。\n- BRI调低：声音变得低沉，像是压在喉咙里放不开的声音。\n\n​\t在调整BRI时，一个音的响度和频率都发生了较大的变化。具体而言，声音调整的越明亮，频谱整体就会向高频偏移；反之亦然。另外，BRI的调整基本不会影响辅音，但是BRI太低可能会导致齿音较重的问题（尤其是洛天依）。\n\n## CLE：清晰度\n\n​\tCLE调高后，声音会变得锋利。基本不作调整。\n\n## OPE：开口度\n\n​\tOPE默认拉满，只能向下降低调整。但是如果将一整个音的开口度都设置小，运用于某些长音就不适合，歌姬就像是含着东西在发声一样，听起来很奇怪。如果想要调整全曲歌姬演唱的口型，单纯设置OPE不能解决问题，只能拆音。\n\n## GEN：性别值  \n\n​\t调整歌姬音色的共振峰，让声音**更偏向于男声或者女声**。这个参数通常全段一致处理，不对每个字进行单修。\n\n- GEN调高：声音变粗，更像男声。但是鼻音增大，声音会变软一些。\n- GEN降低：声音变细，更像女声。\n\n## POR：滑音时间\n\n​\t在音符与音符之间的衔接处，会有衔接的滑音。比如从C3-do升高到mi，歌姬的音调并不是阶跃式的抬升，而是平滑地向上增加。调整POR前可以先开启“音高渲染”，将音高线显示在音符上，会更加直观。\n\n<img src=\"https://s2.loli.net/2024/10/28/9wcrpn1agUEP4hB.png\" style=\"zoom:50%;\" />\n\n- POR调高：前一个音符会更慢地划向后一个。\n- POR调低：前一个音符会更快地划向后一个。\n\n​\tPOR一般不需要大动，个别字精修就行了，整体调整会导致歌姬发声的不自然。\n\n## XSY：交叉演奏参数\n\n​\tXSY参数用于混合两个歌姬的声线，其常规用法是**混合同一个歌姬的不同声线**。比如，用不同比例混合洛天依的meng和ning的音色。XSY主要用于解决一个歌姬的**音域**问题，比如洛天依可以在高音部分混合一些乐正绫进行改善。\n\n​\t调整前首先需要设置“第二歌手”：【设置】--【当前歌手属性(A)】--【双击当前歌手】--【第二歌手】\n\n<img src=\"https://s2.loli.net/2024/10/28/jUJFMZL5iWytNI7.png\" style=\"zoom:50%;\" />\n\n- XSY越大：第二歌手的影响就更大。\n\n​\t一个歌姬的第二歌手由官方给定并限制，如果我们想要混合其他同语种的歌姬，可以在V4编辑器的声库管理工具Vocaloid Voice Management中进行解锁。另外，这是V4编辑器特有的功能，在V5和V6编辑器中反而删除了这个功能。\n\n## GWL：咆哮声\n\n\n\n## PIT：滑音\n\n​\tPIT参数用于**调整“音高”**，是最重要的参数。其直观效果是：\n\n- 从中线向下拉低一半：降低一个半音。\n- 从中线向下拉低到底：降低两个半音。\n\n​\tPIT的调教是VOCALOID调教的核心，也是一个调教师水平和风格的最直观体现。PIT的变化对歌曲的情绪等方面都有着很大的影响。其它参数多如牛毛的微调，有时可能还没有PIT的一笔来得有效果。PIT还可以控制转音和颤音。\n\n​\t另外，PIT的功能很强大，比如我们可以用PIT手绘颤音：\n\n<img src=\"https://s2.loli.net/2024/10/28/hUp6St9TmlMuBg8.png\" style=\"zoom:50%;\" />\n\n","tags":["vocaloid"],"categories":["VOCALOID"]},{"title":"CPP实现蚁群算法(ACO)并解决TSP问题","url":"/2024/10/22/TSP-CPP/","content":"## 问题简述\n\nGiven a set of n nodes and distances for each pair of nodes, find aroundtrip of minimal total length visiting each node exactly once. The distance from node i to node j is the same as from node j to node i.\n\nBerlin52 – 52 locations in Berlin (Germany)\n\n\n## 完整代码\n\n{% codeblock lang:cpp %}\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n#include <chrono>\n\nusing namespace std;\n\n//Super-Parameters\nconst int ITERATION_TIMES = 200;\nconst int ANT_NUMBER = 100;\nconst int CITY_NUMBER = 50;    //DataSet: Berin52\nconst double ALPHA = 2.0;\nconst double BETA = 1.0;\nconst double ROW = 0.4;\n\nconst double information_init = 1.14;\n\ntypedef vector<vector<double>>  Matrix;   \n\nstruct Ant\n{\n    vector<int> route;           //(目前为止)路径\n    double  TotalRouteLength;    //(目前为止)路径的总长度\n};\n\nclass TSP{\n    public:\n        TSP(Matrix DistancesMatrix) : DistancesMatrix(DistancesMatrix){\n            city_number = DistancesMatrix.size();   //城市数量：通过距离矩阵获取\n            InformationMatrix = Matrix(city_number,vector<double>(city_number,information_init));   //初始化信息素矩阵\n        }\n        void solve();\n        //获取最佳情况\n        double GetBestRouteLength();\n        vector<int> GetBestRoute();\n\n    private:\n        //存储最佳情况\n        double BestRouteLength = numeric_limits<double>::max();    //初始值需要赋予一个很大的值\n        vector<int> BestRoute;\n        //一般参数\n        int city_number;\n        //距离矩阵，信息素矩阵\n        Matrix DistancesMatrix;\n        Matrix InformationMatrix;\n\n        //三个核心方法\n        int Select_NextCity(Ant& this_ant);           //传入Ant结构体的一个对象\n        double Calculate_TotalLength(Ant& this_ant);\n        void Update_Information(vector<Ant>& ants);\n};\n\n/*\n    TSP的主要算法流程---------------------------------\n*/\nvoid TSP::solve()\n{\n    for(int iter=0; iter<ITERATION_TIMES; iter++){\n        cout << \"------第\" << iter+1 << \"次算法迭代\" << \"------\" << endl;\n        vector<Ant> ants(ANT_NUMBER);       //####创建存放Ant结构体变量的数组，开辟的空间数量为ANT_NUMBER\n        for(int i = 0; i < ANT_NUMBER; i++){        //第i只蚂蚁\n            ants[i].route.push_back(rand() % city_number);   //Step1:初始化蚂蚁所在节点（随机）\n            cout << \"|||第\" << i+1 << \"只蚂蚁：初始位置为\" << ants[i].route.back() << \"|||\" << endl;\n\n            for(int j = 0; j < city_number - 1; j++){   //第j步移动\n                int nextCity = Select_NextCity(ants[i]);     //Step2:选择下一个前往的节点,结果push到route集合中去。重复直到走遍所有节点。#核心：Select_NextCity()方法\n                ants[i].route.push_back(nextCity);\n                cout << \"!!!第\" << j+1 << \"步:移动到\" << nextCity << endl;\n            }\n            ants[i].TotalRouteLength = Calculate_TotalLength(ants[i]);  //Step3:计算该蚂蚁(i)当前路径下的总距离，然后看看是不是最佳情况。#核心：Calculate_TotalLength()方法\n            cout << \"-->路径长：\" << ants[i].TotalRouteLength << endl;\n            if(ants[i].TotalRouteLength < BestRouteLength)\n            {\n                BestRouteLength = ants[i].TotalRouteLength;\n                BestRoute = ants[i].route;\n            }\n            cout << \"目前为止最佳的路径长：\" << BestRouteLength << endl;\n        }\n        //Step4:所有蚂蚁的情况运行结束，现在开始根据ants所有成员存储的route信息，更新信息素矩阵。#核心：Update_Information()方法\n        Update_Information(ants);\n        //Step5:本次迭代结束，进入下一个迭代。\n    }\n}\n\n/*\n    Select_NextCity:路径选择\n*/\nint TSP::Select_NextCity(Ant& this_ant)\n{\n    //this_ant.route存储了已经经过的结点，类型是vector<int>。在选择下一个目的节点时，需要跳过这些节点。\n    //创建概率列表Probabilities：从当前节点i往其他节点走的概率p_k(i,j)\n    vector<double> Probabilities(city_number,0.0);   \n\n    int NowCity = this_ant.route.back();    //NowCity：当前所在的节点，即route列表的最后一项\n    double totalProbabilities = 0.0;\n    //Step1: 计算每个情况的概率(分子)\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        //需要跳过已经访问的节点,前往他们的概率保持为0.0\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n\n        double information_goto_nextcity = InformationMatrix[NowCity][NextCity];\n        double distance_goto_nextcity = DistancesMatrix[NowCity][NextCity];\n        Probabilities[NextCity] = pow(information_goto_nextcity, ALPHA) * pow(1.0/distance_goto_nextcity, BETA);\n        totalProbabilities += Probabilities[NextCity];\n        //cout << \"#Probabilities:[Before]\" << Probabilities[NextCity] << endl;\n    }\n    //cout << \"#totalProbabilities:\" << totalProbabilities << endl;\n\n    //Step2:计算每个情况的条件概率p_k(i,j)\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n        Probabilities[NextCity] = Probabilities[NextCity] / totalProbabilities;\n        //cout << \"#Probabilities:[After]\" << Probabilities[NextCity] << endl;\n    }\n\n    //Step3:轮盘赌选择去往的下一个节点\n    double  randVal = (double)rand() / RAND_MAX * totalProbabilities;\n    //cout << \"#randVal:\" << randVal << endl;\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n\n        randVal -= Probabilities[NextCity] * totalProbabilities;\n        if (randVal <= 0){\n            return NextCity;\n        }\n    }\n\n    return -1;    //ERROR\n}\n\n/*\n    Calculate_TotalLength:计算路径总长\n*/\ndouble TSP::Calculate_TotalLength(Ant& this_ant)\n{\n    double totalLength = 0.0;\n    for(int i = 0; i < this_ant.route.size()-1; i++){\n        totalLength += DistancesMatrix[this_ant.route[i]][this_ant.route[i+1]];\n    }\n    totalLength += DistancesMatrix[this_ant.route.back()][this_ant.route[0]];  //终点回到起点\n    return totalLength;\n}\n\n/*\n    Update_Information:更新信息素矩阵\n*/\nvoid TSP::Update_Information(vector<Ant>& ants)\n{\n    //Step1: 信息素蒸发\n    for(int i = 0; i < InformationMatrix[0].size(); i++){\n        for(int j = 0; j < InformationMatrix[0].size(); j++){\n            InformationMatrix[i][j] = InformationMatrix[i][j] * (1 - ROW);\n        }\n    }\n\n    //Step2: 信息素释放：每只蚂蚁经过的路径上，都会留下一定的信息素。留下信息素的量规定为距离的倒数\n    for(int i = 0; i < ants.size(); i++){\n        for(int j = 0; j < ants[i].route.size() - 1; j++){\n            int StartPoint = ants[i].route[j];\n            int Destination = ants[i].route[j+1];\n            InformationMatrix[StartPoint][Destination] += 1.0 / ants[i].TotalRouteLength;\n        }\n        InformationMatrix[ants[i].route.back()][ants[i].route[0]] += 1.0 / ants[i].TotalRouteLength;   //终点回到起点\n    }\n}\n\nvector<int> TSP::GetBestRoute()\n{\n    return BestRoute;\n}\ndouble TSP::GetBestRouteLength()\n{\n    return BestRouteLength;\n}\n\n\nint main(){\n\n    srand(static_cast<unsigned>(time(0)));\n\n    //测试集要求：主对角线全0，其他元素不能出现0（否则两点就重合了，必定报错）\n    /* Test: 5-CITY\n    Matrix distances = {\n        {0, 2, 9, 10, 7},\n        {1, 0, 6, 4, 3},\n        {15, 7, 0, 8, 6},\n        {6, 3, 12, 0, 5},\n        {10, 4, 8, 7, 0}\n    };\n    */\n\n    Matrix distances = {\n        {0, 2, 9, 10, 7, 4, 8, 12, 5, 6, 3, 15, 14, 11, 13, 9, 8, 7, 5, 6, 4, 3, 2, 1, 8, 9, 7, 5, 6, 12, 10, 14, 16, 8, 11, 9, 15, 10, 14, 6, 7, 5, 3, 8, 9, 10, 12, 11, 13, 9},\n        {2, 0, 6, 4, 3, 7, 5, 8, 9, 10, 11, 12, 13, 14, 15, 7, 8, 5, 6, 4, 3, 10, 12, 11, 9, 8, 6, 5, 7, 11, 12, 13, 14, 9, 8, 10, 11, 7, 5, 6, 4, 3, 9, 10, 8, 7, 6, 5, 4, 2},\n        {9, 6, 0, 8, 5, 12, 14, 11, 10, 9, 15, 6, 8, 7, 9, 8, 10, 12, 14, 15, 6, 7, 9, 11, 12, 13, 14, 16, 15, 12, 10, 9, 7, 8, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16},\n        {10, 4, 8, 0, 7, 9, 10, 12, 14, 11, 8, 7, 6, 5, 4, 8, 9, 10, 12, 11, 14, 13, 12, 15, 14, 11, 10, 8, 9, 10, 11, 12, 13, 14, 15, 16, 11, 10, 9, 12, 8, 7, 6, 5, 4, 3, 2, 1, 8, 7},\n        {7, 3, 5, 7, 0, 8, 9, 10, 12, 14, 11, 10, 9, 8, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 11, 10, 9, 8, 7, 6, 5, 4, 3},\n        {4, 7, 12, 9, 8, 0, 6, 10, 11, 13, 14, 15, 16, 12, 10, 9, 8, 7, 5, 4, 6, 5, 7, 9, 8, 10, 11, 12, 14, 15, 11, 10, 12, 13, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n        {8, 5, 14, 10, 9, 6, 0, 12, 11, 13, 14, 15, 16, 12, 11, 10, 9, 8, 7, 6, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4},\n        {12, 8, 11, 12, 10, 10, 12, 0, 14, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 10, 9, 8, 6, 7, 8, 10, 11, 12, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5},\n        {5, 9, 10, 14, 12, 11, 11, 14, 0, 6, 5, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 10, 12, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 9},\n        {6, 10, 9, 11, 14, 13, 12, 11, 6, 0, 5, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6},\n        {3, 11, 15, 8, 11, 14, 14, 9, 5, 5, 0, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 7, 6, 5, 4},\n        {15, 12, 6, 7, 10, 15, 15, 8, 9, 7, 7, 0, 3, 4, 5, 6, 8, 10, 12, 14, 15, 11, 12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 11, 10, 9, 8, 7, 6, 5},\n        {14, 13, 8, 5, 9, 16, 12, 11, 8, 11, 9, 3, 0, 6, 7, 8, 9, 10, 12, 11, 14, 15, 14, 12, 10, 8, 6, 4, 3, 2, 1, 9, 10, 11, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 11, 10},\n        {11, 14, 7, 8, 6, 12, 11, 9, 10, 9, 8, 4, 6, 0, 2, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 14, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n        {13, 15, 9, 4, 6, 15, 14, 6, 8, 8, 7, 5, 7, 2, 0, 5, 6, 7, 8, 9, 10, 11, 12, 10, 9, 8, 6, 4, 3, 2, 1, 11, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5},\n        {9, 7, 8, 8, 5, 11, 14, 9, 12, 11, 5, 6, 9, 5, 5, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n        {8, 8, 10, 9, 4, 8, 12, 8, 9, 10, 8, 7, 10, 7, 6, 3, 0, 2, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2},\n        {7, 5, 12, 10, 1, 9, 10, 7, 10, 9, 8, 6, 8, 5, 6, 4, 2, 0, 4, 6, 8, 10, 11, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15, 16, 14, 12, 10, 9},\n        {5, 6, 14, 15, 4, 10, 9, 6, 8, 10, 6, 5, 11, 9, 8, 5, 4, 4, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 8, 9, 10, 11, 12, 13},\n        {6, 4, 15, 12, 6, 11, 12, 10, 11, 9, 5, 8, 12, 8, 9, 6, 6, 6, 2, 0, 2, 4, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15, 16},\n        {4, 3, 6, 4, 10, 5, 10, 8, 7, 10, 7, 5, 8, 9, 10, 9, 8, 6, 3, 2, 0, 3, 4, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14},\n        {3, 10, 7, 10, 9, 5, 9, 6, 8, 7, 3, 6, 10, 5, 5, 4, 3, 4, 4, 3, 3, 0, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14},\n        {2, 12, 9, 12, 8, 7, 8, 9, 10, 6, 7, 9, 12, 11, 10, 5, 6, 6, 4, 3, 2, 4, 0, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14},\n        {1, 11, 11, 15, 7, 6, 7, 10, 7, 11, 6, 5, 10, 8, 9, 6, 5, 10, 3, 2, 1, 5, 5, 0, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11},\n        {8, 9, 12, 14, 6, 10, 11, 12, 6, 7, 8, 7, 9, 12, 10, 9, 8, 8, 6, 4, 3, 6, 7, 3, 0, 8, 9, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 11, 12, 13, 14, 15},\n        {9, 8, 12, 11, 5, 10, 10, 11, 8, 9, 9, 10, 11, 9, 8, 6, 5, 10, 2, 1, 10, 7, 8, 4, 8, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10},\n        {7, 6, 14, 15, 8, 9, 12, 11, 7, 10, 11, 9, 10, 8, 9, 8, 6, 9, 1, 1, 11, 10, 7, 7, 9, 3, 0, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2},\n        {6, 5, 11, 12, 7, 6, 9, 8, 10, 8, 10, 10, 10, 7, 6, 6, 5, 10, 4, 3, 1, 5, 4, 5, 10, 2, 3, 0, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n        {5, 6, 12, 10, 4, 5, 9, 10, 11, 10, 10, 9, 10, 8, 8, 8, 7, 8, 3, 4, 2, 7, 7, 8, 10, 3, 4, 4, 0, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4},\n        {4, 3, 10, 12, 7, 9, 11, 12, 9, 6, 7, 8, 8, 10, 9, 5, 4, 5, 2, 1, 10, 8, 6, 7, 8, 2, 3, 5, 2, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4},\n        {3, 2, 9, 14, 8, 11, 12, 10, 10, 9, 6, 8, 9, 7, 8, 5, 3, 6, 1, 1, 9, 7, 8, 5, 4, 2, 3, 6, 3, 3, 0, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4},\n        {2, 1, 10, 16, 7, 8, 14, 12, 8, 10, 9, 6, 10, 8, 7, 4, 2, 5, 2, 1, 9, 6, 7, 6, 5, 3, 4, 5, 4, 5, 4, 0, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6},\n        {1, 10, 11, 15, 8, 8, 11, 13, 9, 7, 5, 4, 5, 7, 5, 3, 2, 4, 1, 1, 10, 5, 8, 7, 9, 4, 5, 6, 5, 4, 3, 4, 0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5},\n        {2, 1, 10, 15, 6, 8, 10, 8, 10, 10, 8, 5, 8, 5, 9, 4, 3, 3, 2, 2, 8, 5, 4, 5, 4, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16, 14, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\n    };\n\n    TSP tsp(distances);\n\n    auto start = chrono::high_resolution_clock::now();\n    tsp.solve();\n    cout << \"Running the algorithm...\\n\" << flush;\n    auto end = chrono::high_resolution_clock::now();\n    chrono::duration<double> duration = end - start;   //程序运行时间\n\n    vector<int> BestRoute = tsp.GetBestRoute();\n    double  BestRouteLength = tsp.GetBestRouteLength();\n    \n    \n    //Test Ouput\n    cout << \"Algorithm completed!\" << endl;\n    cout << \"\\n\\n==============最终结果==============\\n\";\n    cout << \"最佳路径：\";\n    for(int i = 0 ; i < BestRoute.size() - 1; i++)\n    {\n        cout << BestRoute[i] << \" -> \";\n    }\n    cout << BestRoute.back();\n    cout << \"\\n最佳(最短)路径长：\";\n    cout << BestRouteLength << endl;\n    cout << \"============================||END.\" << endl;\n    cout << \"(本次运行超参数：\" << \"--ITERATION_TIMES=\" << ITERATION_TIMES \n                               << \"--ANT_NUMBER\" << ANT_NUMBER\n                               << \"--ALPHA=\" << ALPHA\n                               << \"--BETA=\" << BETA\n                               << \"--ROW=\" << ROW\n                               << \")\" << endl;\n    cout << \"(程序运行时长：\" << duration << \" seconds)\" << endl;\n\n    return 0;\n}\n{% endcodeblock %}\n\n----------------------\n## 代码逻辑和解析---->2024.10.25更新完毕\n\n### 算法载体“蚂蚁”的结构体表征\n\n{% codeblock lang:cpp %}\nstruct Ant\n{\n    vector<int> route;           //(目前为止)路径\n    double  TotalRouteLength;    //(目前为止)路径的总长度\n};\n{% endcodeblock %}\n\n- **route**: 路径，是一个存放int的一维vector。比如{3,2,1,4,5}，表示该蚂蚁的行走路径是3->2->1->4->5，蚂蚁当前正位于节点5。算法的运行过程中，在每只蚂蚁、每一次根据概率选择完毕下一个节点后，route需要在末尾实时存入(push_back)这个目的节点。\n- **TotalRouteLength**：每一次迭代完成后(即一只蚂蚁走遍了所有节点)，存放route路径的总长度。\n\n### 距离矩阵和信息素矩阵\n\n{% codeblock lang:cpp %}\ntypedef vector<vector<double>>  Matrix;\n//距离矩阵，信息素矩阵\nMatrix DistancesMatrix;\nMatrix InformationMatrix;\n{% endcodeblock %}\n\n- 矩阵的第i行第j列元素，表示从i节点到j节点“路径的距离”/“路径上信息素的含量”。\n- DistancesMatrix是算法的输入，他反映了当前TSP问题的城市个数和它们之间的位置关系(彼此间的距离)；\n- i->j与j->i路径相同只是方向相反，同一条路径上的距离和信息素都应该相同。因此，DistancesMatrix和InformationMatrix都是主对角线全0的对称矩阵。\n\n### 算法主逻辑solve()\n\n{% codeblock lang:cpp %}\nvoid TSP::solve()\n{\n    for(int iter=0; iter<ITERATION_TIMES; iter++){\n        vector<Ant> ants(ANT_NUMBER);       //####创建存放Ant结构体变量的数组，开辟的空间数量为ANT_NUMBER\n        for(int i = 0; i < ANT_NUMBER; i++){        //第i只蚂蚁\n            ants[i].route.push_back(rand() % city_number);   //Step1:初始化蚂蚁所在节点（随机）\n            for(int j = 0; j < city_number - 1; j++){   //第j步移动\n                int nextCity = Select_NextCity(ants[i]);     //Step2:选择下一个前往的节点,结果push到route集合中去。重复直到走遍所有节点。#核心：Select_NextCity()方法\n                ants[i].route.push_back(nextCity);\n            }\n            ants[i].TotalRouteLength = Calculate_TotalLength(ants[i]);  //Step3:计算该蚂蚁(i)当前路径下的总距离，然后看看是不是最佳情况。#核心：Calculate_TotalLength()方法\n            if(ants[i].TotalRouteLength < BestRouteLength)\n            {\n                BestRouteLength = ants[i].TotalRouteLength;\n                BestRoute = ants[i].route;\n            }\n        }\n        //Step4:所有蚂蚁的情况运行结束，现在开始根据ants所有成员存储的route信息，更新信息素矩阵。#核心：Update_Information()方法\n        Update_Information(ants);\n        //Step5:本次迭代结束，进入下一个迭代。\n    }\n}\n{% endcodeblock %}\n\n- 三重循环：最外层循环控制算法总迭代次数；i循环遍历每只蚂蚁；j循环控制每只蚂蚁进行寻路。\n- 核心方法调用：\n    - **Select_NextCity**：传入当前蚂蚁(结构体)。因为结构体中包含了蚂蚁现在的位置信息now(route的末尾元素)，因此可以遍历计算概率p(now,next)，并通过轮盘赌选择下一步的节点编号next。\n    - **Calculate_TotalLength**：最内j循环运行完毕，即当前蚂蚁已经走遍所有节点，运算总路径长。随后确认是否是最佳情况。\n    - **Update_Information**：所有蚂蚁寻路完毕，本次迭代完成，根据每只蚂蚁的路径route更新信息素矩阵。\n- 另外：ants为所有蚂蚁的集合，数据类型是存放结构体对象的一维vector。\n\n*算法主逻辑手写版：\n<img src=\"https://s2.loli.net/2024/10/25/sdcKDOQLRIMgqbt.jpg\" width=\"500\" height=\"1200\">\n\n### 核心方法·其一：Select_NextCity路径选择\n\n{% codeblock lang:cpp %}\nint TSP::Select_NextCity(Ant& this_ant)\n{\n    //this_ant.route存储了已经经过的结点，类型是vector<int>。在选择下一个目的节点时，需要跳过这些节点。\n    //创建概率列表Probabilities：从当前节点i往其他节点走的概率p_k(i,j)\n    vector<double> Probabilities(city_number,0.0);   \n\n    int NowCity = this_ant.route.back();    //NowCity：当前所在的节点，即route列表的最后一项\n    double totalProbabilities = 0.0;\n    //Step1: 计算每个情况的概率(分子)\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        //需要跳过已经访问的节点,前往他们的概率保持为0.0\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n\n        double information_goto_nextcity = InformationMatrix[NowCity][NextCity];\n        double distance_goto_nextcity = DistancesMatrix[NowCity][NextCity];\n        Probabilities[NextCity] = pow(information_goto_nextcity, ALPHA) * pow(1.0/distance_goto_nextcity, BETA);\n        totalProbabilities += Probabilities[NextCity];\n    }\n\n    //Step2:计算每个情况的条件概率p_k(i,j)\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n        Probabilities[NextCity] = Probabilities[NextCity] / totalProbabilities;\n    }\n\n    //Step3:轮盘赌选择去往的下一个节点\n    double  randVal = (double)rand() / RAND_MAX * totalProbabilities;\n    for(int NextCity = 0; NextCity < city_number; NextCity++){\n        auto visited = find(this_ant.route.begin(), this_ant.route.end(), NextCity);  \n        if(visited != this_ant.route.end())     \n            continue;\n\n        randVal -= Probabilities[NextCity] * totalProbabilities;\n        if (randVal <= 0){\n            return NextCity;\n        }\n    }\n\n    return -1;    //ERROR\n}\n{% endcodeblock %}\n\n- 计算每条路径的**概率p_k(i,j)**。注意需要事先排除已经走过的节点。\n- **轮盘赌**选择去往的下一个节点。\n\n<img src=\"https://s2.loli.net/2024/10/25/QaX1brEvRJWwD4y.jpg\">\n\n### 核心方法·其二：Calculate_TotalLength计算总长\n{% codeblock lang:cpp %}\ndouble TSP::Calculate_TotalLength(Ant& this_ant)\n{\n    double totalLength = 0.0;\n    for(int i = 0; i < this_ant.route.size()-1; i++){\n        totalLength += DistancesMatrix[this_ant.route[i]][this_ant.route[i+1]];\n    }\n    totalLength += DistancesMatrix[this_ant.route.back()][this_ant.route[0]];  //终点回到起点\n    return totalLength;\n}\n{% endcodeblock %}\n\n为了简化代码，solve()在运行时不会让蚂蚁回到起点。但此处我们认为TSP问题仍需要走一个闭环，所以在运算路径总长时需要另外加上从终点(route最后一项)回到起点(route第一项)的距离。\n\n### 核心方法·其三：Update_Information信息素更新\n{% codeblock lang:cpp %}\nvoid TSP::Update_Information(vector<Ant>& ants)\n{\n    //Step1: 信息素蒸发\n    for(int i = 0; i < InformationMatrix[0].size(); i++){\n        for(int j = 0; j < InformationMatrix[0].size(); j++){\n            InformationMatrix[i][j] = InformationMatrix[i][j] * (1 - ROW);\n        }\n    }\n\n    //Step2: 信息素释放：每只蚂蚁经过的路径上，都会留下一定的信息素。留下信息素的量规定为距离的倒数\n    for(int i = 0; i < ants.size(); i++){\n        for(int j = 0; j < ants[i].route.size() - 1; j++){\n            int StartPoint = ants[i].route[j];\n            int Destination = ants[i].route[j+1];\n            InformationMatrix[StartPoint][Destination] += 1.0 / ants[i].TotalRouteLength;\n        }\n        InformationMatrix[ants[i].route.back()][ants[i].route[0]] += 1.0 / ants[i].TotalRouteLength;   //终点回到起点\n    }\n}\n{% endcodeblock %}\n\n- **信息素蒸发**：根据超参数ROW，对上一次迭代后的信息素进行衰减操作。\n- **信息素释放**：根据本轮迭代下每只蚂蚁的路径情况，为每条路径增加信息素。每次增加的信息素量是route总长的倒数(即1/TotalRouteLength)。\n\n<img src=\"https://s2.loli.net/2024/10/25/mZu5AzcKEdyIqOl.jpg\" width=\"500\" height=\"1200\">\n\n## 读取.tsp数据文件---->稍后更新\n\n\n\n## Berlin52数据集测试情况---->稍后更新","tags":["CPP","TSP"],"categories":["Course Assignment","Computational Intelligence"]},{"title":"cpp实现矩阵操作","url":"/2024/10/18/Matrix/","content":"\n## 利用c/cpp的原生二维数组的尝试和问题\nlog(2024.10.18):这样写报错，函数貌似无法用一个二级指针以返回一个二维数组......可能是在函数内声明output数组的作用域仅在函数内部，一旦调用函数结束output指针就会指空。\n\n{% codeblock lang:cpp %}\n/*\n    Matrix_mult方法：\n    - 输入：二维数组A(m*n),二维数组B(p*q)\n    - 输出：A*B矩阵乘法结果，是一个二维数组(m*q)\n*/\ndouble** Matrix_Calculation::Matrix_mult(double** A,double** B,int m,int n,int p,int q) \n{\n    //二维数组(m*n)与(p*q)相乘，必须有n=p，否则无法计算\n    if(n!=p) {\n        cout << \"A矩阵列数：\" << n << \"  B矩阵行数：\" << p << \"  因此无法相乘！\" << endl;\n        return ERROR;\n    }\n\n    int i,j,k;\n    double output[m][q];  \n    for(i=1; i<=m; i++){        //扫A(m*n)矩阵的行(第1行~第m行)\n        for(j=1; j<=q; j++){        //扫B(n*q)矩阵的行(第1列~第q列)\n            for(k=1; k<=n; k++){        //扫A和B的乘项。因为A每一行的元素个数=B每一列的元素个数，因此可以用一个变量扫描。\n                output[i][j] += A[i][k] * B[k][j];\n            }\n            cout << output[i][j] << \" \" << endl;  //结果i行j列的元素运算完毕\n        }\n        cout << \"/n\" << endl;  //结果i行的所有元素运算完毕\n    }\n\n    return output;\n}\n{% endcodeblock %}\n\n\n\nlog(2024.10.18):于是，我不如直接把要返回的output二维数组传入，直接在函数里操作写入，而不是返回。\n\n{% codeblock lang:cpp %}\nint Matrix_Calculation::Matrix_mult(double** A,double** B,int m,int n,int p,int q,double** output) \n{\n    //二维数组(m*n)与(p*q)相乘，必须有n=p，否则无法计算\n    if(n!=p) {\n        cout << \"A矩阵列数：\" << n << \"  B矩阵行数：\" << p << \"  因此无法相乘！\" << endl;\n        return ERROR;\n    }\n\n    int i,j,k;\n    //double output[m][q];  \n    for(i=1; i<=m; i++){        //扫A(m*n)矩阵的行(第1行~第m行)\n        for(j=1; j<=q; j++){        //扫B(n*q)矩阵的行(第1列~第q列)\n            for(k=1; k<=n; k++){        //扫A和B的乘项。因为A每一行的元素个数=B每一列的元素个数，因此可以用一个变量扫描。\n                output[i][j] += A[i][k] * B[k][j];\n            }\n            cout << output[i][j] << \" \" << endl;  //结果i行j列的元素运算完毕\n        }\n        cout << \"/n\" << endl;  //结果i行的所有元素运算完毕\n    }\n    return OK;\n    //return output;\n}\n{% endcodeblock %}\n\nlog(2024.10.18) 但这样使用二重指针貌似也不能正常传参，在函数内需要用特殊的方式来求得地址以访问一个元素，过于复杂。另外，如果使用A[][col]的方式将二维数组传入函数，需要指定一个列数，这就太不自由了。\n\n## 利用Vector进行二维数组的操作\n\n- 矩阵乘法：vector创建的二维数组可以向函数中正常传递，避免了使用指针时的各种麻烦。\n\n{% codeblock lang:cpp %}\n/*\n    Matrix_mult:\n    - 输入：二维数组A(m*n),二维数组B(p*q),C=A*B存放矩阵乘法结果(m*q)\n    - 输出：ERROR/OK返回\n*/\nint Matrix_Calculation::Matrix_mult(vector<vector<double>>& A,vector<vector<double>>& B,vector<vector<double>>& C) \n{\n    //用vector类方法直接获取矩阵行数和列数\n    int m,n,p,q;\n    m = A.size();       //A的行数\n    n = A[0].size();    //A的列数，即求第一行的元素个数\n    p = B.size();\n    q = B[0].size();\n\n    //二维数组(m*n)与(p*q)相乘，必须有n=p，否则无法计算\n    if(n!=p) {\n        cout << \"A矩阵列数：\" << n << \"  B矩阵行数：\" << p << \"  因此无法相乘！\" << endl;\n        return ERROR;\n    }\n\n    int i,j,k;\n    // 初始化结果矩阵 C\n    C.resize(m, vector<double>(q, 0));\n    cout << \"矩阵乘法结果：\" << endl;\n    for(i=0; i<m; i++){        //扫A(m*n)矩阵的行(第1行~第m行)\n        for(j=0; j<q; j++){        //扫B(n*q)矩阵的行(第1列~第q列)\n            for(k=0; k<n; k++){        //扫A和B的乘项。因为A每一行的元素个数=B每一列的元素个数，因此可以用一个变量扫描。\n                C[i][j] += A[i][k] * B[k][j];\n            }\n            cout << C[i][j] << \" \";  //结果i行j列的元素运算完毕\n        }\n        cout << \"\\n\";  //结果i行的所有元素运算完毕\n    }\n    \n    return OK;\n}\n{% endcodeblock %}\n\n- 除了矩阵乘法，矩阵转置和加减法等均同理。\n\n## 完整代码(包括主函数测试段)\n{% codeblock lang:cpp%}\n#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n#define ERROR   -1\n#define OK      0\n\nclass Matrix_Calculation{\n    public:\n        int Matrix_mult(vector<vector<double>>& A,vector<vector<double>>& B,vector<vector<double>>& C);\n        int Matrix_transpose(vector<vector<double>>& A,vector<vector<double>>& B);\n        int Matrix_add(vector<vector<double>>& A,vector<vector<double>>& B,vector<vector<double>>& C);\n};\n\n/*\n    Matrix_mult:\n    - 输入：二维数组A(m*n),二维数组B(p*q),C=A*B存放矩阵乘法结果(m*q)\n    - 输出：ERROR/OK返回\n*/\nint Matrix_Calculation::Matrix_mult(vector<vector<double>>& A,vector<vector<double>>& B,vector<vector<double>>& C) \n{\n    //用vector类方法直接获取矩阵行数和列数\n    int m,n,p,q;\n    m = A.size();       //A的行数\n    n = A[0].size();    //A的列数，即求第一行的元素个数\n    p = B.size();\n    q = B[0].size();\n\n    //二维数组(m*n)与(p*q)相乘，必须有n=p，否则无法计算\n    if(n!=p) {\n        cout << \"A矩阵列数：\" << n << \"  B矩阵行数：\" << p << \"  因此无法相乘！\" << endl;\n        return ERROR;\n    }\n\n    int i,j,k;\n    // 初始化结果矩阵 C\n    C.resize(m, vector<double>(q, 0));\n    cout << \"矩阵乘法结果：\" << endl;\n    for(i=0; i<m; i++){        //扫A(m*n)矩阵的行(第1行~第m行)\n        for(j=0; j<q; j++){        //扫B(n*q)矩阵的行(第1列~第q列)\n            for(k=0; k<n; k++){        //扫A和B的乘项。因为A每一行的元素个数=B每一列的元素个数，因此可以用一个变量扫描。\n                C[i][j] += A[i][k] * B[k][j];\n            }\n            cout << C[i][j] << \" \";  //结果i行j列的元素运算完毕\n        }\n        cout << \"\\n\";  //结果i行的所有元素运算完毕\n    }\n    \n    return OK;\n}\n\n/*\n    Matrix_transpose:\n    - 输入：二维数组A(m*n),B=A^T存放矩转置结果(n*m)\n    - 输出：ERROR/OK返回\n*/\nint Matrix_Calculation::Matrix_transpose(vector<vector<double>>& A,vector<vector<double>>& B)\n{\n    int m,n;\n    m = A.size();\n    n = A[0].size();\n\n    int i,j;\n    B.resize(n, vector<double>(m,0));\n    cout << \"矩阵转置结果：\" << endl;\n    for(i=0; i<m; i++){\n        for(j=0; j<n; j++){\n            B[i][j] = A[j][i];\n            cout << B[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    \n    return OK;\n}\n\n/*\n    Matrix_add:\n    - 输入：二维数组A(m*n),二维数组B(p*q),C=A+B存放矩阵加法结果(m*n)\n    - 输出：ERROR/OK返回\n*/\nint Matrix_Calculation::Matrix_add(vector<vector<double>>& A,vector<vector<double>>& B,vector<vector<double>>& C)\n{\n    //用vector类方法直接获取矩阵行数和列数\n    int m,n,p,q;\n    m = A.size();       //A的行数\n    n = A[0].size();    //A的列数，即求第一行的元素个数\n    p = B.size();\n    q = B[0].size();\n\n    //二维数组相加必须同型\n    if(m!=p || n!=q) {\n        cout << \"不同型无法相加！\" << endl;\n        return ERROR;\n    }\n\n    int i,j;\n    // 初始化结果矩阵 C\n    C.resize(m, vector<double>(n, 0));\n    cout << \"矩阵相加结果：\" << endl;\n    for(i=0; i<m; i++){       \n        for(j=0; j<n; j++){    \n            C[i][j] = A[i][j] + B[i][j];\n            cout << C[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    \n    return OK;    \n}\n\nint main(){\n\n    vector<vector<double>> mul1= {\n        {1.0,2.0},\n        {3.0,4.0}\n    };\n    vector<vector<double>> mul2= {\n        {1.0,1.0},\n        {4.0,5.0}\n    };\n    vector<vector<double>> result;\n\n    Matrix_Calculation handle;\n    int check = handle.Matrix_mult(mul1, mul2, result);\n    int check2 = handle.Matrix_transpose(mul1, result);\n    int check3 = handle.Matrix_add(mul1, mul2, result);\n\n    cout << \"------------\" << endl;\n\n    vector<vector<double>> compmul1= {\n        {1.0,2.0},\n        {3.0,4.0},\n        {5.0,6.0},\n        {7.0,8.0}\n    };\n    vector<vector<double>> compmul2= {\n        {1.0,1.0,4.0,5.0,1.0},\n        {4.0,1.0,9.0,1.0,9.0},\n    };\n    vector<vector<double>> result2;\n    int check4 = handle.Matrix_mult(compmul1, compmul2, result2);\n\n    cout << \"------------\" << endl;\n\n    vector<vector<double>> errmul1= {\n        {1.0,2.0},\n        {3.0,4.0},\n        {5.0,6.0}\n    };\n    vector<vector<double>> errmul2= {\n        {1.0,1.0,4.0,5.0,1.0},\n        {4.0,1.0,9.0,1.0,9.0},\n        {1.0,1.0,4.0,5.0,1.0}\n    };\n    vector<vector<double>> result3;\n    int errcheck = handle.Matrix_mult(errmul1, errmul2, result3);\n    int errcheck2 = handle.Matrix_add(errmul1, errmul2, result3);\n    \n\n    return 0;\n}\n{% endcodeblock %}\n\n运行后终端输出：\n{% codeblock lang:bash%}\n矩阵乘法结果：\n9 11 \n19 23 \n矩阵转置结果：\n1 3 \n2 4 \n矩阵相加结果：\n2 3 \n7 9 \n------------\n矩阵乘法结果：\n9 3 22 7 19 \n19 7 48 19 39 \n29 11 74 31 59 \n39 15 100 43 79 \n------------\nA矩阵列数：2  B矩阵行数：3  因此无法相乘！\n不同型无法相加！\n{% endcodeblock%}","tags":["CPP"],"categories":["LAB EXERCISE"]}]